schema {
  query: RootQuery
  mutation: RootMutation
}

type AcceptUserInvitationResult {
  success: Boolean!
}

"""A method of authentication for an Actor"""
type AccessToken {
  createdAt: DateTime!
  id: ID!
  lastUsedAt: DateTime
  note: String
  owner: Actor!
  revokedAt: DateTime
  updatedAt: DateTime!
  visibleTokenPrefix: String!
}

type AccessTokenMutation {
  """Create an AccessToken for an Actor"""
  createAccessToken(createAccessTokenData: CreateAccessTokenInput!): CreateAccessTokenResponse!

  """Delete an AccessToken"""
  deleteAccessToken(id: ID!): DeleteAccessTokenResult!

  """Revoke an AccessToken"""
  setAccessTokenRevoked(id: ID!, revoked: Boolean): AccessToken!
}

"""
An account is a container owning projects, credentials, billing and other organization
data and settings. Actors may own and be members of accounts.
"""
type Account {
  accessTokens: [AccessToken]! @deprecated(reason: "Legacy access tokens are deprecated")

  """Coalesced project activity for all apps belonging to this account."""
  activityTimelineProjectActivities(
    """ Offset the query """
    createdBefore: DateTime

    """ Types of objects to filter """
    filterTypes: [ActivityTimelineProjectActivityType!]
    limit: Int!
  ): [ActivityTimelineProjectActivity!]!
  appCount: Int!
  appStoreConnectApiKeys: [AppStoreConnectApiKey!]! @deprecated(reason: "Use appStoreConnectApiKeysPaginated")
  appStoreConnectApiKeysPaginated(after: String, before: String, first: Int, last: Int): AccountAppStoreConnectApiKeysConnection!
  appleAppIdentifiers(bundleIdentifier: String): [AppleAppIdentifier!]!
  appleDevices(identifier: String, limit: Int, offset: Int): [AppleDevice!]! @deprecated(reason: "Use appleDevicesPaginated")
  appleDevicesPaginated(after: String, before: String, filter: AppleDeviceFilterInput, first: Int, last: Int): AccountAppleDevicesConnection!
  appleDistributionCertificates: [AppleDistributionCertificate!]! @deprecated(reason: "Use appleDistributionCertificatesPaginated")
  appleDistributionCertificatesPaginated(after: String, before: String, first: Int, last: Int): AccountAppleDistributionCertificatesConnection!
  appleProvisioningProfiles(appleAppIdentifierId: ID): [AppleProvisioningProfile!]! @deprecated(reason: "Use appleProvisioningProfilesPaginated")
  appleProvisioningProfilesPaginated(after: String, before: String, first: Int, last: Int): AccountAppleProvisioningProfilesConnection!
  applePushKeys: [ApplePushKey!]! @deprecated(reason: "Use applePushKeysPaginated")
  applePushKeysPaginated(after: String, before: String, first: Int, last: Int): AccountApplePushKeysConnection!
  appleTeams(appleTeamIdentifier: String, limit: Int, offset: Int): [AppleTeam!]! @deprecated(reason: "Use appleTeamsPaginated")

  """iOS credentials for account"""
  appleTeamsPaginated(after: String, before: String, filter: AppleTeamFilterInput, first: Int, last: Int): AccountAppleTeamsConnection!

  """Apps associated with this account"""
  apps(includeUnpublished: Boolean, limit: Int!, offset: Int!): [App!]! @deprecated(reason: "Use appsPaginated")

  """
  Paginated list of apps associated with this account. By default sorted by name. Use filter to adjust the sorting order.
  """
  appsPaginated(after: String, before: String, filter: AccountAppsFilterInput, first: Int, last: Int): AccountAppsConnection!

  """Audit logs for account"""
  auditLogsPaginated(after: String, before: String, filter: AuditLogFilterInput, first: Int, last: Int): AuditLogConnection!
  availableBuilds: Int @deprecated(reason: "Build packs are no longer supported")

  """
  Billing information. Only visible to members with the ADMIN or OWNER role.
  """
  billing: Billing
  billingPeriod(date: DateTime!): BillingPeriod!

  """(EAS Build) Builds associated with this account"""
  builds(limit: Int!, offset: Int!, platform: AppPlatform, status: BuildStatus): [Build!]!
  createdAt: DateTime!

  """Environment secrets for an account"""
  environmentSecrets(filterNames: [String!]): [EnvironmentSecret!]!

  """Environment variables for an account"""
  environmentVariables(environment: EnvironmentVariableEnvironment, filterNames: [String!]): [EnvironmentVariable!]!

  """Environment variables for an account with decrypted secret values"""
  environmentVariablesIncludingSensitive(environment: EnvironmentVariableEnvironment, filterNames: [String!]): [EnvironmentVariableWithSecret!]!

  """GitHub App installations for an account"""
  githubAppInstallations: [GitHubAppInstallation!]!
  googleServiceAccountKeys: [GoogleServiceAccountKey!]! @deprecated(reason: "Use googleServiceAccountKeysPaginated")

  """Android credentials for account"""
  googleServiceAccountKeysPaginated(after: String, before: String, first: Int, last: Int): AccountGoogleServiceAccountKeysConnection!
  hasBuilds: Boolean!
  id: ID!
  isCurrent: Boolean!
  isDisabled: Boolean!

  """
  Whether an Account plan falls into AppDevDomainName's free or paid tier
  """
  isFreeAppDevDomainTier: Boolean!

  """Whether this account has SSO enabled. Can be queried by all members."""
  isSSOEnabled: Boolean!
  lastDeletionAttemptTime: DateTime
  logRocketOrganization: LogRocketOrganization
  name: String!

  """Offers set on this account"""
  offers: [Offer!]

  """Owning User of this account if personal account"""
  owner: User

  """Owning UserActor of this account if personal account"""
  ownerUserActor: UserActor
  pendingSentryInstallation: PendingSentryInstallation
  profileImageUrl: String!
  pushSecurityEnabled: Boolean!
  requiresAccessTokenForPushSecurity: Boolean! @deprecated(reason: "Legacy access tokens are deprecated")
  sentryInstallation: SentryInstallation

  """Snacks associated with this account"""
  snacks(limit: Int!, offset: Int!): [Snack!]!

  """SSO configuration for this account"""
  ssoConfiguration: AccountSSOConfiguration

  """Subscription info visible to members that have VIEWER role"""
  subscription: SubscriptionDetails
  subscriptionChangesPending: Boolean @deprecated(reason: "No longer needed")

  """Coalesced project activity for an app using pagination"""
  timelineActivity(after: String, before: String, filter: TimelineActivityFilterInput, first: Int, last: Int): TimelineActivityConnection!
  unlimitedBuilds: Boolean! @deprecated(reason: "See isCurrent")
  updatedAt: DateTime!

  """Account query object for querying EAS usage metrics"""
  usageMetrics: AccountUsageMetrics!

  """Owning UserActor of this account if personal account"""
  userActorOwner: UserActor @deprecated(reason: "Deprecated in favor of ownerUserActor")

  """Pending user invitations for this account"""
  userInvitations: [UserInvitation!]!

  """Actors associated with this account and permissions they hold"""
  users: [UserPermission!]!

  """Permission info for the viewer on this account"""
  viewerUserPermission: UserPermission!
  willAutoRenewBuilds: Boolean @deprecated(reason: "Build packs are no longer supported")
}

type AccountAppStoreConnectApiKeysConnection {
  edges: [AccountAppStoreConnectApiKeysEdge!]!
  pageInfo: PageInfo!
}

type AccountAppStoreConnectApiKeysEdge {
  cursor: String!
  node: AppStoreConnectApiKey!
}

type AccountAppleDevicesConnection {
  edges: [AccountAppleDevicesEdge!]!
  pageInfo: PageInfo!
}

type AccountAppleDevicesEdge {
  cursor: String!
  node: AppleDevice!
}

type AccountAppleDistributionCertificatesConnection {
  edges: [AccountAppleDistributionCertificatesEdge!]!
  pageInfo: PageInfo!
}

type AccountAppleDistributionCertificatesEdge {
  cursor: String!
  node: AppleDistributionCertificate!
}

type AccountAppleProvisioningProfilesConnection {
  edges: [AccountAppleProvisioningProfilesEdge!]!
  pageInfo: PageInfo!
}

type AccountAppleProvisioningProfilesEdge {
  cursor: String!
  node: AppleProvisioningProfile!
}

type AccountApplePushKeysConnection {
  edges: [AccountApplePushKeysEdge!]!
  pageInfo: PageInfo!
}

type AccountApplePushKeysEdge {
  cursor: String!
  node: ApplePushKey!
}

type AccountAppleTeamsConnection {
  edges: [AccountAppleTeamsEdge!]!
  pageInfo: PageInfo!
}

type AccountAppleTeamsEdge {
  cursor: String!
  node: AppleTeam!
}

type AccountAppsConnection {
  edges: [AccountAppsEdge!]!
  pageInfo: PageInfo!
}

type AccountAppsEdge {
  cursor: String!
  node: App!
}

input AccountAppsFilterInput {
  searchTerm: String
  sortByField: AccountAppsSortByField!
}

enum AccountAppsSortByField {
  LATEST_ACTIVITY_TIME

  """
  Name prefers the display name but falls back to full_name with @account/
  part stripped.
  """
  NAME
}

input AccountDataInput {
  name: String!
}

type AccountGoogleServiceAccountKeysConnection {
  edges: [AccountGoogleServiceAccountKeysEdge!]!
  pageInfo: PageInfo!
}

type AccountGoogleServiceAccountKeysEdge {
  cursor: String!
  node: GoogleServiceAccountKey!
}

type AccountMutation {
  """Cancels all subscriptions immediately"""
  cancelAllSubscriptionsImmediately(accountID: ID!): Account!

  """Cancel scheduled subscription change"""
  cancelScheduledSubscriptionChange(accountID: ID!): Account!

  """
  Buys or revokes account's additional concurrencies, charging the account the appropriate amount if needed.
  """
  changeAdditionalConcurrenciesCount(accountID: ID!, newAdditionalConcurrenciesCount: Int!): Account!

  """
  Upgrades or downgrades the active subscription to the newPlanIdentifier, which must be one of the EAS plans (i.e., Production or Enterprise).
  """
  changePlan(accountID: ID!, couponCode: String, newPlanIdentifier: String!): Account!

  """
  Add specified account Permissions for Actor. Actor must already have at least one permission on the account.
  """
  grantActorPermissions(accountID: ID!, actorID: ID!, permissions: [Permission]): Account!

  """
  Remove profile image for the account. Do nothing if there's no profile image associated.
  """
  removeProfileImage(accountID: ID!): Account!

  """
  Rename this account and the primary user's username if this account is a personal account
  """
  rename(accountID: ID!, newName: String!): Account!

  """
  Requests a refund for the specified charge by requesting a manual refund from support
  """
  requestRefund(accountID: ID!, chargeID: ID!, description: String, reason: String): Boolean

  """
  Revoke specified Permissions for Actor. Actor must already have at least one permission on the account.
  """
  revokeActorPermissions(accountID: ID!, actorID: ID!, permissions: [Permission]): Account!

  """
  Require authorization to send push notifications for experiences owned by this account
  """
  setPushSecurityEnabled(accountID: ID!, pushSecurityEnabled: Boolean!): Account!
}

input AccountNotificationSubscriptionInput {
  accountId: ID!
  event: NotificationEvent!
  type: NotificationType!
  userId: ID!
}

type AccountQuery {
  """Query an Account by ID"""
  byId(
    """Account id to use to look up account"""
    accountId: String!
  ): Account!

  """Query an Account by name"""
  byName(
    """Account name to use to look up account"""
    accountName: String!
  ): Account!
}

"""Auth configuration data for an SSO account."""
type AccountSSOConfiguration {
  authProtocol: AuthProtocolType!
  authProviderIdentifier: AuthProviderIdentifier!
  clientIdentifier: String!
  clientSecret: String!
  createdAt: DateTime!
  id: ID!
  issuer: String!
  updatedAt: DateTime!
}

input AccountSSOConfigurationData {
  authProtocol: AuthProtocolType!
  authProviderIdentifier: AuthProviderIdentifier!
  clientIdentifier: String!
  clientSecret: String!
  issuer: String!
}

type AccountSSOConfigurationMutation {
  """Create an AccountSSOConfiguration for an Account"""
  createAccountSSOConfiguration(accountId: ID!, accountSSOConfigurationData: AccountSSOConfigurationData!): AccountSSOConfiguration!

  """Delete an AccountSSOConfiguration"""
  deleteAccountSSOConfiguration(id: ID!): DeleteAccountSSOConfigurationResult!

  """Update an AccountSSOConfiguration"""
  updateAccountSSOConfiguration(accountSSOConfigurationData: AccountSSOConfigurationData!, id: ID!): AccountSSOConfiguration!
}

"""Public auth configuration data for an SSO account."""
type AccountSSOConfigurationPublicData {
  authProtocol: AuthProtocolType!
  authProviderIdentifier: AuthProviderIdentifier!
  authorizationUrl: String!
  id: ID!
  issuer: String!
}

type AccountSSOConfigurationPublicDataQuery {
  """Get AccountSSOConfiguration public data by account name"""
  publicDataByAccountName(
    """Account name to use to look up account SSO configuration"""
    accountName: String!
  ): AccountSSOConfigurationPublicData!
}

enum AccountUploadSessionType {
  PROFILE_IMAGE_UPLOAD
  WORKFLOWS_PROJECT_SOURCES
}

type AccountUsageEASBuildMetadata {
  billingResourceClass: EASBuildBillingResourceClass
  platform: AppPlatform
  waiverType: EASBuildWaiverType
}

union AccountUsageMetadata = AccountUsageEASBuildMetadata

type AccountUsageMetric {
  id: ID!
  metricType: UsageMetricType!
  serviceMetric: EASServiceMetric!
  timestamp: DateTime!
  value: Float!
}

type AccountUsageMetrics {
  byBillingPeriod(date: DateTime!, service: EASService): UsageMetricTotal!
  metricsForServiceMetric(filterParams: JSONObject, granularity: UsageMetricsGranularity!, serviceMetric: EASServiceMetric!, timespan: UsageMetricsTimespan!): [AccountUsageMetric!]!
}

interface ActivityTimelineProjectActivity {
  activityTimestamp: DateTime!
  actor: Actor
  id: ID!
}

enum ActivityTimelineProjectActivityType {
  BUILD
  SUBMISSION
  UPDATE
  WORKER
  WORKFLOW_RUN
}

"""
A regular user, SSO user, or robot that can authenticate with Expo services and be a member of accounts.
"""
interface Actor {
  """Access Tokens belonging to this actor"""
  accessTokens: [AccessToken!]!

  """Associated accounts"""
  accounts: [Account!]!
  created: DateTime!

  """
  Best-effort human readable name for this actor for use in user interfaces during action attribution.
  For example, when displaying a sentence indicating that actor X created a build or published an update.
  """
  displayName: String!

  """Experiments associated with this actor"""
  experiments: [ActorExperiment!]!

  """
  Server feature gate values for this actor, optionally filtering by desired gates.
  Only resolves for the viewer.
  """
  featureGates(filter: [String!]): JSONObject!
  firstName: String
  id: ID!
  isExpoAdmin: Boolean!
  lastDeletionAttemptTime: DateTime
}

type ActorExperiment {
  createdAt: DateTime!
  enabled: Boolean!
  experiment: Experiment!
  id: ID!
  updatedAt: DateTime!
}

type ActorExperimentMutation {
  """Create or update the value of a User Experiment"""
  createOrUpdateActorExperiment(enabled: Boolean!, experiment: Experiment!): ActorExperiment!
}

type ActorQuery {
  """Query an Actor by ID"""
  byId(id: ID!): Actor! @deprecated(reason: "Public actor queries are no longer supported")
}

input AddUserInput {
  audience: MailchimpAudience = EXPO_DEVELOPERS
  email: String!
  tags: [MailchimpTag!]
}

type AddUserPayload {
  email_address: String
  id: String
  list_id: String
  status: String
  tags: [MailchimpTagPayload!]
  timestamp_signup: String
}

type AddonDetails {
  id: ID!
  name: String!
  nextInvoice: DateTime
  planId: String!
  quantity: Int
  willCancel: Boolean
}

type Address {
  city: String
  country: String
  line1: String
  state: String
  zip: String
}

type AndroidAppBuildCredentials {
  androidKeystore: AndroidKeystore
  id: ID!
  isDefault: Boolean!
  isLegacy: Boolean!
  name: String!
}

"""
@isDefault: if set, these build credentials will become the default for the Android app. All other build credentials will have their default status set to false.
"""
input AndroidAppBuildCredentialsInput {
  isDefault: Boolean!
  keystoreId: ID!
  name: String!
}

type AndroidAppBuildCredentialsMutation {
  """Create a set of build credentials for an Android app"""
  createAndroidAppBuildCredentials(androidAppBuildCredentialsInput: AndroidAppBuildCredentialsInput!, androidAppCredentialsId: ID!): AndroidAppBuildCredentials!

  """delete a set of build credentials for an Android app"""
  deleteAndroidAppBuildCredentials(id: ID!): deleteAndroidAppBuildCredentialsResult!

  """Set the build credentials to be the default for the Android app"""
  setDefault(id: ID!, isDefault: Boolean!): AndroidAppBuildCredentials!

  """Set the keystore to be used for an Android app"""
  setKeystore(id: ID!, keystoreId: ID!): AndroidAppBuildCredentials!

  """
  Set the name of a set of build credentials to be used for an Android app
  """
  setName(id: ID!, name: String!): AndroidAppBuildCredentials!
}

type AndroidAppCredentials {
  androidAppBuildCredentialsArray: [AndroidAppBuildCredentials!]! @deprecated(reason: "use androidAppBuildCredentialsList instead")
  androidAppBuildCredentialsList: [AndroidAppBuildCredentials!]!
  androidFcm: AndroidFcm
  app: App!
  applicationIdentifier: String
  googleServiceAccountKeyForFcmV1: GoogleServiceAccountKey
  googleServiceAccountKeyForSubmissions: GoogleServiceAccountKey
  id: ID!
  isLegacy: Boolean!
}

input AndroidAppCredentialsFilter {
  applicationIdentifier: String
  legacyOnly: Boolean
}

input AndroidAppCredentialsInput {
  fcmId: ID
  googleServiceAccountKeyForFcmV1Id: ID
  googleServiceAccountKeyForSubmissionsId: ID
}

type AndroidAppCredentialsMutation {
  """Create a set of credentials for an Android app"""
  createAndroidAppCredentials(androidAppCredentialsInput: AndroidAppCredentialsInput!, appId: ID!, applicationIdentifier: String!): AndroidAppCredentials!

  """
  Create a GoogleServiceAccountKeyEntity to store credential and
  connect it with an edge from AndroidAppCredential
  """
  createFcmV1Credential(accountId: ID!, androidAppCredentialsId: String!, credential: String!): AndroidAppCredentials!

  """Delete a set of credentials for an Android app"""
  deleteAndroidAppCredentials(id: ID!): DeleteAndroidAppCredentialsResult!

  """Set the FCM push key to be used in an Android app"""
  setFcm(fcmId: ID!, id: ID!): AndroidAppCredentials!

  """
  Set the Google Service Account Key to be used for Firebase Cloud Messaging V1
  """
  setGoogleServiceAccountKeyForFcmV1(googleServiceAccountKeyId: ID!, id: ID!): AndroidAppCredentials!

  """
  Set the Google Service Account Key to be used for submitting an Android app
  """
  setGoogleServiceAccountKeyForSubmissions(googleServiceAccountKeyId: ID!, id: ID!): AndroidAppCredentials!
}

enum AndroidBuildType {
  APK
  APP_BUNDLE

  """@deprecated Use developmentClient option instead."""
  DEVELOPMENT_CLIENT
}

input AndroidBuilderEnvironmentInput {
  bun: String
  corepack: Boolean
  env: JSONObject
  expoCli: String
  image: String
  ndk: String
  node: String
  pnpm: String
  yarn: String
}

type AndroidFcm {
  account: Account!
  createdAt: DateTime!

  """
  Legacy FCM: returns the Cloud Messaging token, parses to a String
  FCM v1: returns the Service Account Key file, parses to an Object
  """
  credential: JSON!
  id: ID!
  snippet: FcmSnippet!
  updatedAt: DateTime!
  version: AndroidFcmVersion!
}

input AndroidFcmInput {
  credential: String!
  version: AndroidFcmVersion!
}

type AndroidFcmMutation {
  """Create an FCM V0/Legacy credential"""
  createAndroidFcm(accountId: ID!, androidFcmInput: AndroidFcmInput!): AndroidFcm! @deprecated(reason: "FCM Legacy credentials are no longer supported by Google. Use createFcmV1Credential instead.")

  """Delete an FCM V0/Legacy credential"""
  deleteAndroidFcm(id: ID!): deleteAndroidFcmResult!
}

enum AndroidFcmVersion {
  LEGACY
  V1
}

input AndroidJobBuildCredentialsInput {
  keystore: AndroidJobKeystoreInput!
}

input AndroidJobInput {
  applicationArchivePath: String

  """@deprecated"""
  artifactPath: String
  buildArtifactPaths: [String!]
  buildProfile: String
  buildType: AndroidBuildType
  builderEnvironment: AndroidBuilderEnvironmentInput
  cache: BuildCacheInput
  customBuildConfig: CustomBuildConfigInput
  developmentClient: Boolean
  environment: EnvironmentVariableEnvironment
  experimental: JSONObject
  gradleCommand: String
  loggerLevel: WorkerLoggerLevel
  mode: BuildMode
  projectArchive: ProjectArchiveSourceInput!
  projectRootDirectory: String!
  releaseChannel: String
  secrets: AndroidJobSecretsInput
  triggeredBy: BuildTrigger
  type: BuildWorkflow!
  updates: BuildUpdatesInput
  username: String
  version: AndroidJobVersionInput
}

input AndroidJobKeystoreInput {
  dataBase64: String!
  keyAlias: String!
  keyPassword: String
  keystorePassword: String!
}

input AndroidJobOverridesInput {
  applicationArchivePath: String

  """@deprecated"""
  artifactPath: String
  buildArtifactPaths: [String!]
  buildProfile: String
  buildType: AndroidBuildType
  builderEnvironment: AndroidBuilderEnvironmentInput
  cache: BuildCacheInput
  customBuildConfig: CustomBuildConfigInput
  developmentClient: Boolean
  experimental: JSONObject
  gradleCommand: String
  loggerLevel: WorkerLoggerLevel
  mode: BuildMode
  releaseChannel: String
  secrets: AndroidJobSecretsInput
  updates: BuildUpdatesInput
  username: String
  version: AndroidJobVersionInput
}

input AndroidJobSecretsInput {
  buildCredentials: AndroidJobBuildCredentialsInput
  robotAccessToken: String
}

input AndroidJobVersionInput {
  versionCode: String!
}

type AndroidKeystore {
  account: Account!
  createdAt: DateTime!
  id: ID!
  keyAlias: String!
  keyPassword: String
  keystore: String!
  keystorePassword: String!
  md5CertificateFingerprint: String
  sha1CertificateFingerprint: String
  sha256CertificateFingerprint: String
  type: AndroidKeystoreType!
  updatedAt: DateTime!
}

input AndroidKeystoreInput {
  base64EncodedKeystore: String!
  keyAlias: String!
  keyPassword: String
  keystorePassword: String!
}

type AndroidKeystoreMutation {
  """Create a Keystore"""
  createAndroidKeystore(accountId: ID!, androidKeystoreInput: AndroidKeystoreInput!): AndroidKeystore

  """Delete a Keystore"""
  deleteAndroidKeystore(id: ID!): DeleteAndroidKeystoreResult!
}

enum AndroidKeystoreType {
  JKS
  PKCS12
  UNKNOWN
}

type AndroidSubmissionConfig {
  applicationIdentifier: String @deprecated(reason: "applicationIdentifier is deprecated and will be auto-detected on submit")
  archiveType: SubmissionAndroidArchiveType @deprecated(reason: "archiveType is deprecated and will be null")
  releaseStatus: SubmissionAndroidReleaseStatus
  rollout: Float
  track: SubmissionAndroidTrack!
}

input AndroidSubmissionConfigInput {
  applicationIdentifier: String
  archiveUrl: String
  changesNotSentForReview: Boolean
  googleServiceAccountKeyId: String
  googleServiceAccountKeyJson: String
  isVerboseFastlaneEnabled: Boolean
  releaseStatus: SubmissionAndroidReleaseStatus
  rollout: Float
  track: SubmissionAndroidTrack!
}

"""Represents an Exponent App (or Experience in legacy terms)"""
type App implements Project {
  accessTokens: [AccessToken]! @deprecated(reason: "Legacy access tokens are deprecated")

  """Coalesced project activity for an app"""
  activityTimelineProjectActivities(
    """ Offset the query """
    createdBefore: DateTime
    filterChannels: [String!]
    filterPlatforms: [AppPlatform!]

    """ Types of objects to filter """
    filterTypes: [ActivityTimelineProjectActivityType!]
    limit: Int!
  ): [ActivityTimelineProjectActivity!]!

  """Android app credentials for the project"""
  androidAppCredentials(filter: AndroidAppCredentialsFilter): [AndroidAppCredentials!]!

  """ios.appStoreUrl field from most recent classic update manifest"""
  appStoreUrl: String @deprecated(reason: "Classic updates have been deprecated.")
  assetLimitPerUpdateGroup: Int!
  branchesPaginated(after: String, before: String, filter: BranchFilterInput, first: Int, last: Int): AppBranchesConnection!

  """(EAS Build) Builds associated with this app"""
  builds(
    filter: BuildFilter
    limit: Int!
    offset: Int!

    """Deprecated, use filter instead"""
    platform: AppPlatform

    """Deprecated, use filter instead"""
    status: BuildStatus
  ): [Build!]!
  buildsPaginated(after: String, before: String, filter: BuildFilterInput, first: Int, last: Int): AppBuildsConnection!

  """Classic update release channel names that have at least one build"""
  buildsReleaseChannels: [String!]! @deprecated(reason: "Classic updates have been deprecated.")
  channelsPaginated(after: String, before: String, filter: ChannelFilterInput, first: Int, last: Int): AppChannelsConnection!
  deployment(channel: String!, runtimeVersion: String!): Deployment

  """Deployments associated with this app"""
  deployments(after: String, before: String, filter: DeploymentFilterInput, first: Int, last: Int): DeploymentsConnection!
  description: String! @deprecated(reason: "Classic updates have been deprecated.")
  devDomainName: AppDevDomainName

  """Environment secrets for an app"""
  environmentSecrets(filterNames: [String!]): [EnvironmentSecret!]!

  """Environment variables for an app"""
  environmentVariables(environment: EnvironmentVariableEnvironment, filterNames: [String!]): [EnvironmentVariable!]!

  """Environment variables for an app with decrypted secret values"""
  environmentVariablesIncludingSensitive(environment: EnvironmentVariableEnvironment, filterNames: [String!]): [EnvironmentVariableWithSecret!]!
  fingerprintsPaginated(after: String, before: String, filter: FingerprintFilterInput, first: Int, last: Int): AppFingerprintsConnection!
  fullName: String!
  githubBuildTriggers: [GitHubBuildTrigger!]!
  githubJobRunTriggers: [GitHubJobRunTrigger!]!
  githubRepository: GitHubRepository
  githubRepositorySettings: GitHubRepositorySettings

  """githubUrl field from most recent classic update manifest"""
  githubUrl: String @deprecated(reason: "Classic updates have been deprecated.")

  """
  Info about the icon specified in the most recent classic update manifest
  """
  icon: AppIcon @deprecated(reason: "Classic updates have been deprecated.")
  iconUrl: String @deprecated
  id: ID!

  """App query field for querying EAS Insights about this app"""
  insights: AppInsights!
  internalDistributionBuildPrivacy: AppInternalDistributionBuildPrivacy!

  """iOS app credentials for the project"""
  iosAppCredentials(filter: IosAppCredentialsFilter): [IosAppCredentials!]!
  isDeleting: Boolean! @deprecated(reason: "Use lastDeletionAttemptTime !== null instead")

  """
  Whether the latest classic update publish is using a deprecated SDK version
  """
  isDeprecated: Boolean! @deprecated(reason: "Classic updates have been deprecated.")
  isLikedByMe: Boolean! @deprecated(reason: "'likes' have been deprecated.")
  lastDeletionAttemptTime: DateTime
  lastPublishedTime: DateTime! @deprecated

  """Time of the last user activity (update, branch, submission)."""
  latestActivity: DateTime!
  latestAppVersionByPlatformAndApplicationIdentifier(applicationIdentifier: String!, platform: AppPlatform!): AppVersion
  latestReleaseForReleaseChannel(platform: AppPlatform!, releaseChannel: String!): AppRelease @deprecated(reason: "Classic updates have been deprecated.")

  """ID of latest classic update release"""
  latestReleaseId: ID! @deprecated(reason: "Classic updates have been deprecated.")
  likeCount: Int! @deprecated(reason: "'likes' have been deprecated.")
  likedBy(limit: Int, offset: Int): [User]! @deprecated(reason: "'likes' have been deprecated.")
  logRocketProject: LogRocketProject
  name: String!
  ownerAccount: Account!
  packageName: String! @deprecated
  packageUsername: String! @deprecated

  """android.playStoreUrl field from most recent classic update manifest"""
  playStoreUrl: String @deprecated(reason: "Classic updates have been deprecated.")
  privacy: String! @deprecated
  privacySetting: AppPrivacy! @deprecated
  profileImageUrl: String

  """Whether there have been any classic update publishes"""
  published: Boolean! @deprecated(reason: "Classic updates have been deprecated.")

  """App query field for querying details about an app's push notifications"""
  pushNotifications: AppPushNotifications!
  pushSecurityEnabled: Boolean!

  """Classic update release channel names (to be removed)"""
  releaseChannels: [String!]! @deprecated(reason: "Classic updates have been deprecated.")
  requiresAccessTokenForPushSecurity: Boolean! @deprecated(reason: "Legacy access tokens are deprecated")
  resourceClassExperiment: ResourceClassExperiment

  """Runtimes associated with this app"""
  runtimes(after: String, before: String, filter: RuntimeFilterInput, first: Int, last: Int): RuntimesConnection!
  scopeKey: String!

  """SDK version of the latest classic update publish, 0.0.0 otherwise"""
  sdkVersion: String! @deprecated(reason: "Classic updates have been deprecated.")
  sentryProject: SentryProject
  slug: String!

  """EAS Submissions associated with this app"""
  submissions(filter: SubmissionFilter!, limit: Int!, offset: Int!): [Submission!]!
  submissionsPaginated(after: String, before: String, first: Int, last: Int): AppSubmissionsConnection!
  suggestedDevDomainName: String!

  """Coalesced project activity for an app using pagination"""
  timelineActivity(after: String, before: String, filter: TimelineActivityFilterInput, first: Int, last: Int): TimelineActivityConnection!
  trendScore: Float! @deprecated(reason: "'likes' have been deprecated.")

  """get an EAS branch owned by the app by name"""
  updateBranchByName(name: String!): UpdateBranch

  """EAS branches owned by an app"""
  updateBranches(limit: Int!, offset: Int!): [UpdateBranch!]!

  """get an EAS channel owned by the app by name"""
  updateChannelByName(name: String!): UpdateChannel

  """EAS channels owned by an app"""
  updateChannels(limit: Int!, offset: Int!): [UpdateChannel!]!

  """EAS updates owned by an app grouped by update group"""
  updateGroups(filter: UpdatesFilter, limit: Int!, offset: Int!): [[Update!]!]!

  """Time of last classic update publish"""
  updated: DateTime! @deprecated(reason: "Classic updates have been deprecated.")

  """EAS updates owned by an app"""
  updates(limit: Int!, offset: Int!): [Update!]!
  updatesPaginated(after: String, before: String, filter: UpdateFilterInput, first: Int, last: Int): AppUpdatesConnection!

  """Project query object for querying EAS usage metrics"""
  usageMetrics: AppUsageMetrics!
  username: String! @deprecated(reason: "Use ownerAccount.name instead")
  users: [User] @deprecated

  """Webhooks for an app"""
  webhooks(filter: WebhookFilter): [Webhook!]!
  workerCustomDomain: WorkerCustomDomain
  workerDeployment(deploymentIdentifier: WorkerDeploymentIdentifier!): WorkerDeployment
  workerDeploymentAlias(aliasName: WorkerDeploymentIdentifier): WorkerDeploymentAlias
  workerDeploymentAliases(after: String, before: String, first: Int, last: Int): WorkerDeploymentAliasesConnection!
  workerDeployments(after: String, before: String, first: Int, last: Int): WorkerDeploymentsConnection!
  workerDeploymentsCrash(crashKey: ID!, sampleFor: CrashSampleFor): WorkerDeploymentCrashEdge!
  workerDeploymentsCrashes(filters: CrashesFilters, timespan: DatasetTimespan!): WorkerDeploymentCrashes
  workerDeploymentsRequest(requestKey: ID!): WorkerDeploymentRequestEdge!
  workerDeploymentsRequests(filters: RequestsFilters, timespan: DatasetTimespan!): WorkerDeploymentRequests
  workflowRunGitBranchesPaginated(after: String, before: String, filter: WorkflowRunGitBranchFilterInput, first: Int, last: Int): AppWorkflowRunGitBranchesConnection!
  workflowRunsPaginated(after: String, before: String, filter: WorkflowRunFilterInput, first: Int, last: Int): AppWorkflowRunsConnection!
  workflows: [Workflow!]!
}

type AppBranchEdge {
  cursor: String!
  node: UpdateBranch!
}

type AppBranchesConnection {
  edges: [AppBranchEdge!]!
  pageInfo: PageInfo!
}

type AppBuildEdge {
  cursor: String!
  node: BuildOrBuildJob!
}

type AppBuildsConnection {
  edges: [AppBuildEdge!]!
  pageInfo: PageInfo!
}

type AppChannelEdge {
  cursor: String!
  node: UpdateChannel!
}

type AppChannelsConnection {
  edges: [AppChannelEdge!]!
  pageInfo: PageInfo!
}

input AppDataInput {
  id: ID!
  internalDistributionBuildPrivacy: AppInternalDistributionBuildPrivacy
  privacy: String
}

type AppDevDomainName {
  app: App
  id: ID!
  name: DevDomainName!
}

type AppDevDomainNameMutation {
  """Creates a DevDomainName assigning it to an app"""
  assignDevDomainName(appId: ID!, name: DevDomainName!): AppDevDomainName!

  """Updates a DevDomainName for a given app"""
  changeDevDomainName(appId: ID!, name: DevDomainName!): AppDevDomainName!
}

type AppFingerprintEdge {
  cursor: String!
  node: Fingerprint!
}

type AppFingerprintsConnection {
  edges: [AppFingerprintEdge!]!
  pageInfo: PageInfo!
}

type AppIcon {
  colorPalette: JSON @deprecated
  originalUrl: String!
  primaryColor: String
  url: String!
}

input AppInfoInput {
  displayName: String
}

input AppInput {
  accountId: ID!
  appInfo: AppInfoInput
  projectName: String!
}

type AppInsights {
  hasEventsFromExpoInsightsClientModule: Boolean!
  totalUniqueUsers(timespan: InsightsTimespan!): Int
  uniqueUsersByAppVersionOverTime(timespan: InsightsTimespan!): UniqueUsersOverTimeData!
  uniqueUsersByPlatformOverTime(timespan: InsightsTimespan!): UniqueUsersOverTimeData!
}

enum AppInternalDistributionBuildPrivacy {
  PRIVATE
  PUBLIC
}

type AppMutation {
  """Create an app"""
  createApp(appInput: AppInput!): App!
  grantAccess(accessLevel: String, toUser: ID!): App @deprecated

  """
  Remove profile image (icon) for the app. Do nothing if there's no profile image associated.
  """
  removeProfileImage(appId: ID!): App!

  """
  Delete an App. Returns the ID of the background job receipt. Use BackgroundJobReceiptQuery to get the status of the job.
  """
  scheduleAppDeletion(appId: ID!): BackgroundJobReceipt!

  """Set display info for app"""
  setAppInfo(appId: ID!, appInfo: AppInfoInput!): App!

  """Require api token to send push notifs for experience"""
  setPushSecurityEnabled(appId: ID!, pushSecurityEnabled: Boolean!): App!

  """Set resource class experiment for app"""
  setResourceClassExperiment(appId: ID!, resourceClassExperiment: ResourceClassExperiment): App!
}

input AppNotificationSubscriptionInput {
  appId: ID!
  event: NotificationEvent!
  type: NotificationType!
  userId: ID!
}

enum AppPlatform {
  ANDROID
  IOS
}

enum AppPrivacy {
  HIDDEN
  PUBLIC
  UNLISTED
}

type AppPushNotifications {
  id: ID!
  insights: AppPushNotificationsInsights!
}

type AppPushNotificationsInsights {
  id: ID!
  notificationsSentOverTime(timespan: InsightsTimespan!): NotificationsSentOverTimeData!
  successFailureOverTime(timespan: InsightsTimespan!): NotificationsSentOverTimeData!
  totalNotificationsSent(filters: [JSON!] = [], timespan: InsightsTimespan!): Int!
}

type AppQuery {
  """Public apps in the app directory"""
  all(
    """Filter to use to filter public app list"""
    filter: AppsFilter!
    limit: Int
    offset: Int

    """Method to sort by"""
    sort: AppSort!
  ): [App!]! @deprecated(reason: "App directory no longer supported")

  """Look up app by dev domain name, if one has been created"""
  byDevDomainName(name: DevDomainName!): App!
  byFullName(
    """App full name used to look up app"""
    fullName: String!
  ): App!

  """Look up app by app id"""
  byId(appId: String!): App!
}

type AppRelease {
  hash: String!
  id: ID!
  manifest: JSON!
  publishedTime: DateTime!
  publishingUsername: String!
  runtimeVersion: String
  s3Key: String!
  s3Url: String!
  sdkVersion: String!
  version: String!
}

enum AppSort {
  """Sort by recently published"""
  RECENTLY_PUBLISHED

  """Sort by highest trendScore"""
  VIEWED
}

type AppStoreConnectApiKey {
  account: Account!
  appleTeam: AppleTeam
  createdAt: DateTime!
  id: ID!
  issuerIdentifier: String!
  keyIdentifier: String!
  keyP8: String!
  name: String
  roles: [AppStoreConnectUserRole!]
  updatedAt: DateTime!
}

input AppStoreConnectApiKeyInput {
  appleTeamId: ID
  issuerIdentifier: String!
  keyIdentifier: String!
  keyP8: String!
  name: String
  roles: [AppStoreConnectUserRole!]
}

type AppStoreConnectApiKeyMutation {
  """Create an App Store Connect Api Key for an Apple Team"""
  createAppStoreConnectApiKey(accountId: ID!, appStoreConnectApiKeyInput: AppStoreConnectApiKeyInput!): AppStoreConnectApiKey!

  """Delete an App Store Connect Api Key"""
  deleteAppStoreConnectApiKey(id: ID!): deleteAppStoreConnectApiKeyResult!

  """Update an App Store Connect Api Key for an Apple Team"""
  updateAppStoreConnectApiKey(appStoreConnectApiKeyUpdateInput: AppStoreConnectApiKeyUpdateInput!, id: ID!): AppStoreConnectApiKey!
}

type AppStoreConnectApiKeyQuery {
  byId(id: ID!): AppStoreConnectApiKey!
}

input AppStoreConnectApiKeyUpdateInput {
  appleTeamId: ID
}

enum AppStoreConnectUserRole {
  ACCESS_TO_REPORTS
  ACCOUNT_HOLDER
  ADMIN
  APP_MANAGER
  CLOUD_MANAGED_APP_DISTRIBUTION
  CLOUD_MANAGED_DEVELOPER_ID
  CREATE_APPS
  CUSTOMER_SUPPORT
  DEVELOPER
  FINANCE
  IMAGE_MANAGER
  MARKETING
  READ_ONLY
  SALES
  TECHNICAL
  UNKNOWN
}

type AppSubmissionEdge {
  cursor: String!
  node: Submission!
}

type AppSubmissionsConnection {
  edges: [AppSubmissionEdge!]!
  pageInfo: PageInfo!
}

type AppUpdateEdge {
  cursor: String!
  node: Update!
}

type AppUpdatesConnection {
  edges: [AppUpdateEdge!]!
  pageInfo: PageInfo!
}

enum AppUploadSessionType {
  PROFILE_IMAGE_UPLOAD
}

type AppUsageMetric {
  id: ID!
  metricType: UsageMetricType!
  serviceMetric: EASServiceMetric!
  timestamp: DateTime!
  value: Float!
}

type AppUsageMetricTotal {
  billingPeriod: BillingPeriod!
  id: ID!
  planMetrics: [EstimatedUsage!]!

  """Total cost of overages, in cents"""
  totalCost: Float!
}

type AppUsageMetrics {
  byBillingPeriod(date: DateTime!, service: EASService): AppUsageMetricTotal!
  metricsForServiceMetric(filterParams: JSONObject, granularity: UsageMetricsGranularity!, serviceMetric: EASServiceMetric!, timespan: UsageMetricsTimespan!): [AppUsageMetric!]!
}

"""Represents Play Store/App Store version of an application"""
type AppVersion {
  """
  Store identifier for an application
   - Android - applicationId
   - iOS - bundle identifier
  """
  applicationIdentifier: String!

  """
  Value that identifies build in a store (it's visible to developers, but not to end users)
  - Android - versionCode in build.gradle ("android.versionCode" field in app.json)
  - iOS - CFBundleVersion in Info.plist ("ios.buildNumber" field in app.json)
  """
  buildVersion: String!
  id: ID!
  platform: AppPlatform!
  runtimeVersion: String

  """
  User-facing version in a store
  - Android - versionName in build.gradle ("version" field in app.json)
  - iOS - CFBundleShortVersionString in Info.plist ("version" field in app.json)
  """
  storeVersion: String!
}

input AppVersionInput {
  appId: ID!
  applicationIdentifier: String!
  buildVersion: String!
  platform: AppPlatform!
  runtimeVersion: String
  storeVersion: String!
}

type AppVersionMutation {
  """Create an app version"""
  createAppVersion(appVersionInput: AppVersionInput!): AppVersion!
}

input AppWithGithubRepositoryInput {
  accountId: ID!
  appInfo: AppInfoInput
  installationIdentifier: String
  projectName: String!
}

type AppWorkflowRunEdge {
  cursor: String!
  node: WorkflowRun!
}

type AppWorkflowRunGitBranchEdge {
  cursor: String!
  node: AppWorkflowRunGitBranchNode!
}

type AppWorkflowRunGitBranchNode {
  lastRunAt: DateTime!
  name: String!
}

type AppWorkflowRunGitBranchesConnection {
  edges: [AppWorkflowRunGitBranchEdge!]!
  pageInfo: PageInfo!
}

type AppWorkflowRunsConnection {
  edges: [AppWorkflowRunEdge!]!
  pageInfo: PageInfo!
}

type AppleAppIdentifier {
  account: Account!
  appleTeam: AppleTeam
  bundleIdentifier: String!
  id: ID!
  parentAppleAppIdentifier: AppleAppIdentifier
}

input AppleAppIdentifierInput {
  appleTeamId: ID
  bundleIdentifier: String!
  parentAppleAppId: ID
}

type AppleAppIdentifierMutation {
  """Create an Identifier for an iOS App"""
  createAppleAppIdentifier(accountId: ID!, appleAppIdentifierInput: AppleAppIdentifierInput!): AppleAppIdentifier!
}

type AppleDevice {
  account: Account!
  appleTeam: AppleTeam!
  createdAt: DateTime!
  deviceClass: AppleDeviceClass
  enabled: Boolean
  id: ID!
  identifier: String!
  model: String
  name: String
  softwareVersion: String
}

enum AppleDeviceClass {
  IPAD
  IPHONE
  MAC
  UNKNOWN
}

input AppleDeviceFilterInput {
  appleTeamIdentifier: String
  class: AppleDeviceClass
  identifier: String
}

input AppleDeviceInput {
  appleTeamId: ID!
  deviceClass: AppleDeviceClass
  enabled: Boolean
  identifier: String!
  model: String
  name: String
  softwareVersion: String
}

type AppleDeviceMutation {
  """Create an Apple Device"""
  createAppleDevice(accountId: ID!, appleDeviceInput: AppleDeviceInput!): AppleDevice!

  """Delete an Apple Device"""
  deleteAppleDevice(id: ID!): DeleteAppleDeviceResult!

  """Update an Apple Device"""
  updateAppleDevice(appleDeviceUpdateInput: AppleDeviceUpdateInput!, id: ID!): AppleDevice!
}

type AppleDeviceRegistrationRequest {
  account: Account!
  appleTeam: AppleTeam!
  id: ID!
}

type AppleDeviceRegistrationRequestMutation {
  """Create an Apple Device registration request"""
  createAppleDeviceRegistrationRequest(accountId: ID!, appleTeamId: ID!): AppleDeviceRegistrationRequest!
}

type AppleDeviceRegistrationRequestQuery {
  byId(id: ID!): AppleDeviceRegistrationRequest!
}

input AppleDeviceUpdateInput {
  name: String
}

type AppleDistributionCertificate {
  account: Account!
  appleTeam: AppleTeam
  certificateP12: String
  certificatePassword: String
  certificatePrivateSigningKey: String
  createdAt: DateTime!
  developerPortalIdentifier: String
  id: ID!
  iosAppBuildCredentialsList: [IosAppBuildCredentials!]!
  serialNumber: String!
  updatedAt: DateTime!
  validityNotAfter: DateTime!
  validityNotBefore: DateTime!
}

input AppleDistributionCertificateInput {
  appleTeamId: ID
  certP12: String!
  certPassword: String!
  certPrivateSigningKey: String
  developerPortalIdentifier: String
}

type AppleDistributionCertificateMutation {
  """Create a Distribution Certificate"""
  createAppleDistributionCertificate(accountId: ID!, appleDistributionCertificateInput: AppleDistributionCertificateInput!): AppleDistributionCertificate

  """Delete a Distribution Certificate"""
  deleteAppleDistributionCertificate(id: ID!): DeleteAppleDistributionCertificateResult!
}

type AppleProvisioningProfile {
  account: Account!
  appleAppIdentifier: AppleAppIdentifier!
  appleDevices: [AppleDevice!]!
  appleTeam: AppleTeam
  appleUUID: String!
  createdAt: DateTime!
  developerPortalIdentifier: String
  expiration: DateTime!
  id: ID!
  provisioningProfile: String
  status: String!
  updatedAt: DateTime!
}

input AppleProvisioningProfileInput {
  appleProvisioningProfile: String!
  developerPortalIdentifier: String
}

type AppleProvisioningProfileMutation {
  """Create a Provisioning Profile"""
  createAppleProvisioningProfile(accountId: ID!, appleAppIdentifierId: ID!, appleProvisioningProfileInput: AppleProvisioningProfileInput!): AppleProvisioningProfile!

  """Delete a Provisioning Profile"""
  deleteAppleProvisioningProfile(id: ID!): DeleteAppleProvisioningProfileResult!

  """Delete Provisioning Profiles"""
  deleteAppleProvisioningProfiles(ids: [ID!]!): [DeleteAppleProvisioningProfileResult!]!

  """Update a Provisioning Profile"""
  updateAppleProvisioningProfile(appleProvisioningProfileInput: AppleProvisioningProfileInput!, id: ID!): AppleProvisioningProfile!
}

type ApplePushKey {
  account: Account!
  appleTeam: AppleTeam
  createdAt: DateTime!
  id: ID!
  iosAppCredentialsList: [IosAppCredentials!]!
  keyIdentifier: String!
  keyP8: String!
  updatedAt: DateTime!
}

input ApplePushKeyInput {
  appleTeamId: ID!
  keyIdentifier: String!
  keyP8: String!
}

type ApplePushKeyMutation {
  """Create an Apple Push Notification key"""
  createApplePushKey(accountId: ID!, applePushKeyInput: ApplePushKeyInput!): ApplePushKey!

  """Delete an Apple Push Notification key"""
  deleteApplePushKey(id: ID!): deleteApplePushKeyResult!
}

type AppleTeam {
  account: Account!
  appleAppIdentifiers(bundleIdentifier: String): [AppleAppIdentifier!]!
  appleDevices(limit: Int, offset: Int): [AppleDevice!]!
  appleDistributionCertificates: [AppleDistributionCertificate!]!
  appleProvisioningProfiles(appleAppIdentifierId: ID): [AppleProvisioningProfile!]!
  applePushKeys: [ApplePushKey!]!
  appleTeamIdentifier: String!
  appleTeamName: String
  appleTeamType: AppleTeamType
  id: ID!
}

input AppleTeamFilterInput {
  appleTeamIdentifier: String
}

input AppleTeamInput {
  appleTeamIdentifier: String!
  appleTeamName: String
  appleTeamType: AppleTeamType
}

type AppleTeamMutation {
  """Create an Apple Team"""
  createAppleTeam(accountId: ID!, appleTeamInput: AppleTeamInput!): AppleTeam!

  """Update an Apple Team"""
  updateAppleTeam(appleTeamUpdateInput: AppleTeamUpdateInput!, id: ID!): AppleTeam!
}

type AppleTeamQuery {
  byAppleTeamIdentifier(accountId: ID!, identifier: String!): AppleTeam
}

enum AppleTeamType {
  COMPANY_OR_ORGANIZATION
  INDIVIDUAL
  IN_HOUSE
}

input AppleTeamUpdateInput {
  appleTeamName: String
  appleTeamType: AppleTeamType
}

enum AppsFilter {
  """Featured Projects"""
  FEATURED

  """New Projects"""
  NEW
}

input AscApiKeyInput {
  issuerIdentifier: String!
  keyIdentifier: String!
  keyP8: String!
}

type Asset {
  contentType: String!
  fileSHA256: String!
  fileSize: Int!
  finalFileSize: Int
  id: ID!
  storageKey: String!
}

input AssetMapGroup {
  android: AssetMapSourceInput
  ios: AssetMapSourceInput
  web: AssetMapSourceInput
}

input AssetMapSourceInput {
  bucketKey: String
  type: AssetMapSourceType
}

enum AssetMapSourceType {
  GCS
}

type AssetMetadataResult {
  status: AssetMetadataStatus!
  storageKey: String!
}

enum AssetMetadataStatus {
  DOES_NOT_EXIST
  EXISTS
}

type AssetMutation {
  """
  Returns an array of specifications for upload. Each URL is valid for an hour.
  The content type of the asset you wish to upload must be specified.
  """
  getSignedAssetUploadSpecifications(
    """max 1400"""
    assetContentTypes: [String]!
  ): GetSignedAssetUploadSpecificationsResult!
}

"""Check to see if assets with given storageKeys exist"""
type AssetQuery {
  byStorageKeys(storageKeys: [String!]!): [Asset!]!
  metadata(storageKeys: [String!]!): [AssetMetadataResult!]!
  signedUrls(storageKeys: [String!]!, updateId: ID!): [AssetSignedUrlResult!]!
}

type AssetSignedUrlResult {
  headers: JSON
  storageKey: String!
  url: String!
}

type AuditLog {
  account: Account
  actor: Actor
  createdAt: DateTime!
  id: ID!
  metadata: JSONObject
  targetEntityId: ID!
  targetEntityMutationType: TargetEntityMutationType!
  targetEntityTypeName: EntityTypeName!
  targetEntityTypePublicName: String!
  websiteMessage: String!
}

type AuditLogConnection {
  edges: [AuditLogEdge!]!
  pageInfo: PageInfo!
}

type AuditLogEdge {
  cursor: String!
  node: AuditLog!
}

input AuditLogExportInput {
  accountId: ID!
  createdAfter: String!
  createdBefore: String!
  format: AuditLogsExportFormat!
  targetEntityMutationType: [TargetEntityMutationType!]
  targetEntityTypeName: [EntityTypeName!]
}

input AuditLogFilterInput {
  entityTypes: [EntityTypeName!]
  mutationTypes: [TargetEntityMutationType!]
}

type AuditLogMutation {
  """
  Exports Audit Logs for an account. Returns the ID of the background job receipt. Use BackgroundJobReceiptQuery to get the status of the job.
  """
  exportAuditLogs(exportInput: AuditLogExportInput!): BackgroundJobReceipt!
}

type AuditLogQuery {
  """Audit logs for account"""
  byId(auditLogId: ID!): AuditLog!
  typeNamesMap: [LogNameTypeMapping!]!
}

enum AuditLogsExportFormat {
  CSV
  JSON
  JSONL
}

enum AuthProtocolType {
  OIDC
}

enum AuthProviderIdentifier {
  GOOGLE_WS
  MS_ENTRA_ID
  OKTA
  ONE_LOGIN
  STUB_IDP
}

type AverageAssetMetrics {
  averageDownloadSizeBytes: Int!
  count: Int!
  storageKey: String!
}

type BackgroundJobReceipt {
  account: Account!
  createdAt: DateTime!
  errorCode: String
  errorMessage: String
  id: ID!
  resultData: JSONObject
  resultId: ID
  resultType: BackgroundJobResultType!
  state: BackgroundJobState!
  tries: Int!
  updatedAt: DateTime!
  willRetry: Boolean!
}

type BackgroundJobReceiptQuery {
  """Look up background job receipt by ID"""
  byId(id: ID!): BackgroundJobReceipt!
}

enum BackgroundJobResultType {
  AUDIT_LOGS_EXPORT
  GITHUB_BUILD
  USER_AUDIT_LOGS_EXPORT
  VOID
}

enum BackgroundJobState {
  FAILURE
  IN_PROGRESS
  QUEUED
  SUCCESS
}

type Billing {
  """History of invoices"""
  charges: [Charge]
  id: ID!
  payment: PaymentDetails @deprecated(reason: "No longer used")
  subscription: SubscriptionDetails
}

type BillingPeriod {
  anchor: DateTime!
  end: DateTime!
  id: ID!
  start: DateTime!
}

input BranchFilterInput {
  searchTerm: String
}

type BranchQuery {
  """Query a Branch by ID"""
  byId(
    """Branch ID to use to look up branch"""
    branchId: ID!
  ): UpdateBranch!
}

"""Represents an EAS Build"""
type Build implements ActivityTimelineProjectActivity & BuildOrBuildJob {
  activityTimestamp: DateTime!
  actor: Actor
  app: App!
  appBuildVersion: String
  appIdentifier: String
  appVersion: String
  artifacts: BuildArtifacts
  buildMode: BuildMode
  buildProfile: String
  canRetry(newMode: BuildMode): Boolean!
  cancelingActor: Actor
  channel: String @deprecated(reason: "Use 'updateChannel' field instead.")
  childBuild: Build
  cliVersion: String
  completedAt: DateTime
  createdAt: DateTime!
  customNodeVersion: String
  customWorkflowName: String
  deployment: Deployment
  developmentClient: Boolean
  distribution: DistributionType
  enqueuedAt: DateTime
  error: BuildError
  estimatedWaitTimeLeftSeconds: Int
  expirationDate: DateTime
  fingerprint: Fingerprint
  gitCommitHash: String
  gitCommitMessage: String
  gitRef: String
  githubRepositoryOwnerAndName: String @deprecated(reason: "Use 'githubRepository' field instead")
  id: ID!

  """Queue position is 1-indexed"""
  initialQueuePosition: Int
  initiatingActor: Actor
  initiatingUser: User @deprecated(reason: "User type is deprecated")
  iosEnterpriseProvisioning: BuildIosEnterpriseProvisioning
  isForIosSimulator: Boolean!
  isGitWorkingTreeDirty: Boolean
  isWaived: Boolean!
  logFiles: [String!]!
  maxBuildTimeSeconds: Int!

  """Retry time starts after completedAt"""
  maxRetryTimeMinutes: Int
  message: String
  metrics: BuildMetrics
  parentBuild: Build
  platform: AppPlatform!
  priority: BuildPriority!
  project: Project! @deprecated(reason: "Use app field instead")
  projectMetadataFileUrl: String
  projectRootDirectory: String
  provisioningStartedAt: DateTime

  """Queue position is 1-indexed"""
  queuePosition: Int
  reactNativeVersion: String
  releaseChannel: String
  requiredPackageManager: String
  resolvedEnvironment: EnvironmentVariableEnvironment

  """The builder resource class requested by the developer"""
  resourceClass: BuildResourceClass! @deprecated(reason: "Use resourceClassDisplayName instead")

  """String describing the resource class used to run the build"""
  resourceClassDisplayName: String!
  retryDisabledReason(newMode: BuildMode): BuildRetryDisabledReason
  runFromCI: Boolean
  runtime: Runtime
  runtimeVersion: String @deprecated(reason: "Use 'runtime' field instead.")
  sdkVersion: String
  selectedImage: String
  status: BuildStatus!
  submissions: [Submission!]!
  updateChannel: UpdateChannel
  updatedAt: DateTime!
  workerStartedAt: DateTime
}

type BuildAnnotation {
  authorUsername: String
  buildPhase: String!
  exampleBuildLog: String
  id: ID!
  internalNotes: String
  message: String!
  regexFlags: String
  regexString: String!
  title: String!
}

input BuildAnnotationDataInput {
  buildPhase: String!
  exampleBuildLog: String
  internalNotes: String
  message: String!
  regexFlags: String
  regexString: String!
  title: String!
}

input BuildAnnotationFiltersInput {
  buildPhases: [String!]!
}

type BuildAnnotationMutation {
  """Create a Build Annotation"""
  createBuildAnnotation(buildAnnotationData: BuildAnnotationDataInput!): BuildAnnotation!

  """Delete a Build Annotation"""
  deleteBuildAnnotation(buildAnnotationId: ID!): DeleteBuildAnnotationResult!

  """Update a Build Annotation"""
  updateBuildAnnotation(buildAnnotationData: BuildAnnotationDataInput!, buildAnnotationId: ID!): BuildAnnotation!
}

type BuildAnnotationsQuery {
  """View build annotations"""
  all(filters: BuildAnnotationFiltersInput): [BuildAnnotation!]!

  """Find a build annotation by ID"""
  byId(buildAnnotationId: ID!): BuildAnnotation!
}

type BuildArtifacts {
  applicationArchiveUrl: String
  buildArtifactsUrl: String
  buildUrl: String
  fingerprintUrl: String @deprecated(reason: "Use 'runtime.fingerprint.debugInfoUrl' instead.")
  xcodeBuildLogsUrl: String
}

input BuildCacheInput {
  clear: Boolean
  disabled: Boolean
  key: String
  paths: [String!]
}

enum BuildCredentialsSource {
  LOCAL
  REMOTE
}

type BuildError {
  buildPhase: BuildPhase
  docsUrl: String
  errorCode: String!
  message: String!
}

input BuildFilter {
  appBuildVersion: String
  appIdentifier: String
  appVersion: String
  buildProfile: String
  channel: String
  developmentClient: Boolean
  distribution: DistributionType
  fingerprintHash: String
  gitCommitHash: String
  hasFingerprint: Boolean
  platform: AppPlatform
  runtimeVersion: String
  sdkVersion: String
  simulator: Boolean
  status: BuildStatus
}

input BuildFilterInput {
  channel: String
  developmentClient: Boolean
  distributions: [DistributionType!]
  fingerprintHash: String
  hasFingerprint: Boolean
  platforms: [AppPlatform!]
  releaseChannel: String
  runtimeVersion: String
  simulator: Boolean
}

enum BuildIosEnterpriseProvisioning {
  ADHOC
  UNIVERSAL
}

type BuildLimitThresholdExceededMetadata {
  account: Account!
  thresholdsExceeded: [NotificationThresholdExceeded!]!
}

enum BuildLimitThresholdExceededMetadataType {
  IOS
  TOTAL
}

input BuildMetadataInput {
  appBuildVersion: String
  appIdentifier: String
  appName: String
  appVersion: String
  buildProfile: String
  channel: String
  cliVersion: String
  credentialsSource: BuildCredentialsSource
  customNodeVersion: String
  customWorkflowName: String
  developmentClient: Boolean
  distribution: DistributionType
  environment: String
  fingerprintHash: String
  fingerprintSource: FingerprintSourceInput
  gitCommitHash: String
  gitCommitMessage: String
  iosEnterpriseProvisioning: BuildIosEnterpriseProvisioning
  isGitWorkingTreeDirty: Boolean
  message: String
  reactNativeVersion: String
  releaseChannel: String
  requiredPackageManager: String
  runFromCI: Boolean
  runWithNoWaitFlag: Boolean
  runtimeVersion: String
  sdkVersion: String
  selectedImage: String
  simulator: Boolean
  trackingContext: JSONObject
  username: String
  workflow: BuildWorkflow
}

type BuildMetrics {
  buildDuration: Int
  buildQueueTime: Int
  buildWaitTime: Int
}

enum BuildMode {
  BUILD
  CUSTOM
  LOCAL
  REPACK
  RESIGN
}

type BuildMutation {
  """Cancel an EAS Build build"""
  cancel: Build! @deprecated(reason: "Use cancelBuild instead")

  """Cancel an EAS Build build"""
  cancelBuild(buildId: ID!): Build!

  """Create an Android build"""
  createAndroidBuild(appId: ID!, buildParams: BuildParamsInput, job: AndroidJobInput!, metadata: BuildMetadataInput): CreateBuildResult!

  """Create an iOS build"""
  createIosBuild(appId: ID!, buildParams: BuildParamsInput, job: IosJobInput!, metadata: BuildMetadataInput): CreateBuildResult!

  """Create a local build"""
  createLocalBuild(appId: ID!, artifactSource: LocalBuildArchiveSourceInput!, job: LocalBuildJobInput!, metadata: BuildMetadataInput): CreateBuildResult!

  """Delete an EAS Build build"""
  deleteBuild(buildId: ID!): Build!

  """Retry an Android EAS Build"""
  retryAndroidBuild(buildId: ID!, jobOverrides: AndroidJobOverridesInput): Build!

  """Retry an EAS Build build"""
  retryBuild(buildId: ID!): Build! @deprecated(reason: "Use retryAndroidBuild and retryIosBuild instead")

  """Retry an iOS EAS Build"""
  retryIosBuild(buildId: ID!, jobOverrides: IosJobOverridesInput): Build!

  """Update metadata for EAS Build build"""
  updateBuildMetadata(buildId: ID!, metadata: BuildMetadataInput!): Build!
}

interface BuildOrBuildJob {
  id: ID!
}

input BuildParamsInput {
  reactNativeVersion: String
  resourceClass: BuildResourceClass!
  sdkVersion: String
}

enum BuildPhase {
  BUILDER_INFO
  CLEAN_UP_CREDENTIALS
  COMPLETE_BUILD
  CONFIGURE_EXPO_UPDATES
  CONFIGURE_XCODE_PROJECT
  CUSTOM
  DOWNLOAD_APPLICATION_ARCHIVE
  EAS_BUILD_INTERNAL
  FAIL_BUILD
  FIX_GRADLEW
  INSTALL_CUSTOM_TOOLS
  INSTALL_DEPENDENCIES
  INSTALL_PODS
  ON_BUILD_CANCEL_HOOK
  ON_BUILD_COMPLETE_HOOK
  ON_BUILD_ERROR_HOOK
  ON_BUILD_SUCCESS_HOOK
  PARSE_CUSTOM_WORKFLOW_CONFIG
  POST_INSTALL_HOOK
  PREBUILD
  PREPARE_ARTIFACTS
  PREPARE_CREDENTIALS
  PREPARE_PROJECT
  PRE_INSTALL_HOOK
  PRE_UPLOAD_ARTIFACTS_HOOK
  QUEUE
  READ_APP_CONFIG
  READ_PACKAGE_JSON
  RESTORE_CACHE
  RUN_EXPO_DOCTOR
  RUN_FASTLANE
  RUN_GRADLEW
  SAVE_CACHE
  SET_UP_BUILD_ENVIRONMENT
  SPIN_UP_BUILDER
  START_BUILD
  UNKNOWN
  UPLOAD_APPLICATION_ARCHIVE
  UPLOAD_ARTIFACTS @deprecated
  UPLOAD_BUILD_ARTIFACTS
}

type BuildPlanCreditThresholdExceededMetadata {
  account: Account!
  buildCreditUsage: Int!
  planLimit: Int!
  threshold: Int!
}

enum BuildPriority {
  HIGH
  NORMAL
  NORMAL_PLUS
}

"""Publicly visible data for a Build."""
type BuildPublicData {
  artifacts: PublicArtifacts!
  buildMode: BuildMode
  distribution: DistributionType
  id: ID!
  isForIosSimulator: Boolean!
  platform: AppPlatform!
  project: ProjectPublicData!
  status: BuildStatus!
}

type BuildPublicDataQuery {
  """Get BuildPublicData by ID"""
  byId(id: ID!): BuildPublicData
}

type BuildQuery {
  """
  Get all builds.
  By default, they are sorted from latest to oldest.
  Available only for admin users.
  """
  all(limit: Int, offset: Int, order: Order, statuses: [BuildStatus!]): [Build!]!

  """
  Get all builds for a specific app.
  They are sorted from latest to oldest.
  """
  allForApp(appId: String!, limit: Int, offset: Int, platform: AppPlatform, status: BuildStatus): [Build]! @deprecated(reason: "Use App.builds instead")

  """Look up EAS Build by build ID"""
  byId(buildId: ID!): Build!
}

input BuildResignInput {
  applicationArchiveSource: ProjectArchiveSourceInput
}

enum BuildResourceClass {
  ANDROID_DEFAULT
  ANDROID_LARGE
  ANDROID_MEDIUM
  IOS_DEFAULT
  IOS_INTEL_LARGE @deprecated(reason: "No longer available. Use IOS_M_LARGE instead.")
  IOS_INTEL_MEDIUM @deprecated(reason: "No longer available. Use IOS_M_MEDIUM instead.")
  IOS_LARGE
  IOS_M1_LARGE @deprecated(reason: "Use IOS_M_MEDIUM instead")
  IOS_M1_MEDIUM @deprecated(reason: "Use IOS_M_MEDIUM instead")
  IOS_MEDIUM
  IOS_M_LARGE
  IOS_M_MEDIUM
  LEGACY
  LINUX_LARGE
  LINUX_MEDIUM
}

enum BuildRetryDisabledReason {
  ALREADY_RETRIED
  INVALID_STATUS
  IS_GITHUB_BUILD
  NOT_COMPLETED_YET
  TOO_MUCH_TIME_ELAPSED
}

enum BuildStatus {
  CANCELED
  ERRORED
  FINISHED
  IN_PROGRESS
  IN_QUEUE
  NEW
  PENDING_CANCEL
}

enum BuildTrigger {
  EAS_CLI
  GIT_BASED_INTEGRATION
}

input BuildUpdatesInput {
  channel: String
}

enum BuildWorkflow {
  GENERIC
  MANAGED
  UNKNOWN
}

type Card {
  brand: String
  cardHolder: String
  expMonth: Int
  expYear: Int
  last4: String
}

input ChannelFilterInput {
  searchTerm: String
}

type ChannelQuery {
  """Query a Channel by ID"""
  byId(
    """Channel ID to use to look up channel"""
    channelId: ID!
  ): UpdateChannel!
}

type Charge {
  amount: Int!
  createdAt: DateTime!
  id: ID!
  invoiceId: String
  paid: Boolean!
  receiptUrl: String
  wasRefunded: Boolean!
}

type CodeSigningInfo {
  alg: String!
  keyid: String!
  sig: String!
}

input CodeSigningInfoInput {
  alg: String!
  keyid: String!
  sig: String!
}

type Concurrencies {
  android: Int!
  ios: Int!
  total: Int!
}

enum ContinentCode {
  AF
  AN
  AS
  EU
  NA
  OC
  SA
  T1
}

enum CrashSampleFor {
  NEWEST
  OLDEST
}

input CrashesFilters {
  crashKind: [WorkerDeploymentCrashKind!]
  name: [String!]
}

input CreateAccessTokenInput {
  actorID: ID!
  note: String
}

type CreateAccessTokenResponse {
  """AccessToken created"""
  accessToken: AccessToken!

  """Full token string to be used for authentication"""
  token: String!
}

input CreateAndConfigureRepositoryInput {
  appId: ID!
  installationIdentifier: Int!
}

input CreateAndroidSubmissionInput {
  appId: ID!
  archiveSource: SubmissionArchiveSourceInput
  archiveUrl: String
  config: AndroidSubmissionConfigInput!
  submittedBuildId: ID
}

type CreateBuildResult {
  build: Build!
  deprecationInfo: EASBuildDeprecationInfo
}

input CreateEnvironmentSecretInput {
  name: String!
  type: EnvironmentSecretType
  value: String!
}

input CreateEnvironmentVariableInput {
  environments: [EnvironmentVariableEnvironment!]
  fileName: String
  name: String!
  overwrite: Boolean
  type: EnvironmentSecretType
  value: String!
  visibility: EnvironmentVariableVisibility!
}

input CreateFingerprintInput {
  hash: String!
  source: FingerprintSourceInput
}

input CreateGitHubAppInstallationInput {
  accountId: ID!
  installationIdentifier: Int!
}

input CreateGitHubBuildTriggerInput {
  appId: ID!
  autoSubmit: Boolean!
  buildProfile: String!
  environment: EnvironmentVariableEnvironment
  executionBehavior: GitHubBuildTriggerExecutionBehavior!
  isActive: Boolean!
  platform: AppPlatform!

  """
  A branch or tag name, or a wildcard pattern where the code change originates from. For example, `main` or `release/*`.
  """
  sourcePattern: String!
  submitProfile: String

  """
  A branch name or a wildcard pattern that the pull request targets. For example, `main` or `release/*`.
  """
  targetPattern: String
  type: GitHubBuildTriggerType!
}

input CreateGitHubJobRunTriggerInput {
  appId: ID!
  isActive: Boolean!
  jobType: GitHubJobRunJobType!
  sourcePattern: String!
  targetPattern: String
  triggerType: GitHubJobRunTriggerType!
}

input CreateGitHubRepositoryInput {
  appId: ID!
  githubAppInstallationId: ID!
  githubRepositoryIdentifier: Int!
  nodeIdentifier: String!
}

input CreateGitHubRepositorySettingsInput {
  appId: ID!

  """
  The base directory is the directory to change to before starting a build. This string should be a properly formatted POSIX path starting with '/', './', or the name of the directory relative to the root of the repository. Valid examples include: '/apps/expo-app', './apps/expo-app', and 'apps/expo-app'. This is intended for monorepos or apps that live in a subdirectory of a repository.
  """
  baseDirectory: String!
}

input CreateIosSubmissionInput {
  appId: ID!
  archiveSource: SubmissionArchiveSourceInput
  archiveUrl: String
  config: IosSubmissionConfigInput!
  submittedBuildId: ID
}

input CreateSentryProjectInput {
  appId: ID!
  sentryProjectId: String!
  sentryProjectSlug: String!
}

input CreateSharedEnvironmentVariableInput {
  environments: [EnvironmentVariableEnvironment!]
  fileName: String
  isGlobal: Boolean
  name: String!
  overwrite: Boolean
  type: EnvironmentSecretType
  value: String!
  visibility: EnvironmentVariableVisibility!
}

type CreateSubmissionResult {
  """Created submission"""
  submission: Submission!
}

type CumulativeAverageMetrics {
  averageUpdatePayloadBytes: Int!
  launchAssetCount: Int!
}

type CumulativeMetrics {
  data: UpdatesMetricsData!
  metricsAtLastTimestamp: CumulativeMetricsTotals!
}

type CumulativeMetricsOverTimeData {
  data: LineChartData!
  metricsAtLastTimestamp: [LineDatapoint!]!
}

type CumulativeMetricsTotals {
  totalFailedInstalls: Int!
  totalInstalls: Int!
}

type CumulativeUpdatesDataset {
  cumulative: [Int!]!
  difference: [Int!]!
  id: String!
  label: String!
}

input CustomBuildConfigInput {
  path: String!
}

type CustomDomainDNSRecord {
  dnsContent: String!
  dnsName: String!
  dnsType: CustomDomainDNSRecordType!
  isConfigured: Boolean!
}

enum CustomDomainDNSRecordType {
  A
  CNAME
  TXT
}

type CustomDomainMutation {
  deleteCustomDomain(customDomainId: ID!): DeleteCustomDomainResult!
  refreshCustomDomain(customDomainId: ID!): WorkerCustomDomain!
  registerCustomDomain(aliasName: WorkerDeploymentIdentifier, appId: ID!, hostname: String!): WorkerCustomDomain!
}

type CustomDomainSetup {
  sslErrors: [String!]
  sslStatus: CustomDomainStatus
  status: CustomDomainStatus!
  verificationErrors: [String!]
  verificationStatus: CustomDomainStatus
}

enum CustomDomainStatus {
  ACTIVE
  ERROR
  PENDING
  TIMED_OUT
}

input DatasetTimespan {
  end: DateTime!
  start: DateTime!
}

"""Date custom scalar type"""
scalar DateTime

type DeleteAccessTokenResult {
  id: ID!
}

type DeleteAccountResult {
  id: ID!
}

type DeleteAccountSSOConfigurationResult {
  id: ID!
}

type DeleteAliasResult {
  aliasName: WorkerDeploymentIdentifier
  id: ID!
}

type DeleteAndroidAppCredentialsResult {
  id: ID!
}

type DeleteAndroidKeystoreResult {
  id: ID!
}

type DeleteAppleDeviceResult {
  id: ID!
}

type DeleteAppleDistributionCertificateResult {
  id: ID!
}

type DeleteAppleProvisioningProfileResult {
  id: ID!
}

type DeleteBuildAnnotationResult {
  buildAnnotationId: ID!
}

type DeleteCustomDomainResult {
  appId: ID!
  hostname: String!
  id: ID!
}

type DeleteDiscordUserResult {
  id: ID!
}

type DeleteEnvironmentSecretResult {
  id: ID!
}

type DeleteEnvironmentVariableResult {
  id: ID!
}

type DeleteGitHubUserResult {
  id: ID!
}

type DeleteGoogleServiceAccountKeyResult {
  id: ID!
}

type DeleteIosAppBuildCredentialsResult {
  id: ID!
}

type DeleteIosAppCredentialsResult {
  id: ID!
}

type DeleteLogRocketOrganizationResult {
  accountId: ID!
}

type DeleteLogRocketProjectResult {
  id: ID!
}

type DeleteRobotResult {
  id: ID!
}

type DeleteSSOUserResult {
  id: ID!
}

type DeleteSentryProjectResult {
  id: ID!
}

type DeleteUpdateBranchResult {
  id: ID!
}

type DeleteUpdateChannelResult {
  id: ID!
}

type DeleteUpdateGroupResult {
  group: ID!
}

type DeleteWebhookResult {
  id: ID!
}

type DeleteWorkerDeploymentResult {
  deploymentIdentifier: WorkerDeploymentIdentifier!
  id: ID!
}

"""
Represents a Deployment - a set of Builds with the same Runtime Version and Channel
"""
type Deployment {
  buildCount(statuses: [BuildStatus!]): Int!
  builds(after: String, before: String, first: Int, last: Int): DeploymentBuildsConnection!
  channel: UpdateChannel!
  id: ID!

  """Deployment query field"""
  insights: DeploymentInsights!

  """Ordered the same way as 'updateBranches' in UpdateChannel"""
  latestUpdatesPerBranch(limit: Int!, offset: Int!): [LatestUpdateOnBranch!]!
  runtime: Runtime!
}

type DeploymentBuildEdge {
  cursor: String!
  node: Build!
}

"""Represents the connection over the builds edge of a Deployment"""
type DeploymentBuildsConnection {
  edges: [DeploymentBuildEdge!]!
  pageInfo: PageInfo!
}

type DeploymentCumulativeMetricsOverTimeData {
  data: LineChartData!
  metricsAtLastTimestamp: [LineDatapoint!]!
  mostPopularUpdates: [Update!]!
}

type DeploymentEdge {
  cursor: String!
  node: Deployment!
}

input DeploymentFilterInput {
  channel: String
  runtimeVersion: String
}

type DeploymentInsights {
  cumulativeMetricsOverTime(timespan: InsightsTimespan!): DeploymentCumulativeMetricsOverTimeData!
  embeddedUpdateTotalUniqueUsers(timespan: InsightsTimespan!): Int!
  embeddedUpdateUniqueUsersOverTime(timespan: InsightsTimespan!): UniqueUsersOverTimeData!
  id: ID!
  mostPopularUpdates(timespan: InsightsTimespan!): [Update!]!
  uniqueUsersOverTime(timespan: InsightsTimespan!): UniqueUsersOverTimeData!
}

type DeploymentQuery {
  """Query a Deployment by ID"""
  byId(
    """Deployment ID to use to look up deployment"""
    deploymentId: ID!
  ): Deployment!
}

type DeploymentResult {
  data: UpdateDeploymentsConnection
  error: String
  success: Boolean!
}

type DeploymentSignedUrlResult {
  deploymentIdentifier: ID!
  pendingWorkerDeploymentId: ID!
  url: String!
}

"""Represents the connection over the deployments edge of an App"""
type DeploymentsConnection {
  edges: [DeploymentEdge!]!
  pageInfo: PageInfo!
}

type DeploymentsMutation {
  assignAlias(aliasName: WorkerDeploymentIdentifier, appId: ID!, deploymentIdentifier: ID!): WorkerDeploymentAlias!

  """Create a signed deployment URL"""
  createSignedDeploymentUrl(appId: ID!, deploymentIdentifier: ID): DeploymentSignedUrlResult!
  deleteAlias(aliasName: WorkerDeploymentIdentifier, appId: ID!): DeleteAliasResult!
  deleteWorkerDeployment(workerDeploymentId: ID!): DeleteWorkerDeploymentResult!
}

"""A DevDomainName for a deployed serverless app"""
scalar DevDomainName

type DiscordUser {
  discordIdentifier: String!
  id: ID!
  metadata: DiscordUserMetadata
  userActor: UserActor!
}

type DiscordUserMetadata {
  discordAvatarUrl: String!
  discordDiscriminator: String!
  discordUsername: String!
}

type DiscordUserMutation {
  """Delete a Discord User by ID"""
  deleteDiscordUser(id: ID!): DeleteDiscordUserResult!
}

enum DistributionType {
  INTERNAL
  SIMULATOR
  STORE
}

enum EASBuildBillingResourceClass {
  LARGE
  MEDIUM
}

type EASBuildDeprecationInfo {
  message: String!
  type: EASBuildDeprecationInfoType!
}

enum EASBuildDeprecationInfoType {
  INTERNAL
  USER_FACING
}

enum EASBuildWaiverType {
  FAST_FAILED_BUILD
  SYSTEM_ERROR
}

enum EASService {
  BUILDS
  JOBS
  UPDATES
}

enum EASServiceMetric {
  ASSETS_REQUESTS
  BANDWIDTH_USAGE
  BUILDS
  LOCAL_BUILDS
  MANIFEST_REQUESTS
  RUN_TIME
  UNIQUE_UPDATERS
  UNIQUE_USERS
}

type EASTotalPlanEnablement {
  total: Int!
  unit: EASTotalPlanEnablementUnit
}

enum EASTotalPlanEnablementUnit {
  BUILD
  BYTE
  CONCURRENCY
  REQUEST
  UPDATER
  USER
}

input EditUpdateBranchInput {
  appId: ID
  id: ID
  name: String
  newName: String!
}

type EmailSubscriptionMutation {
  addUser(addUserInput: AddUserInput!): AddUserPayload!
}

enum EntityTypeName {
  AccountEntity
  AccountSSOConfigurationEntity
  AndroidAppCredentialsEntity
  AndroidKeystoreEntity
  AppEntity
  AppStoreConnectApiKeyEntity
  AppleDeviceEntity
  AppleDistributionCertificateEntity
  AppleProvisioningProfileEntity
  AppleTeamEntity
  BranchEntity
  ChannelEntity
  CustomerEntity
  GoogleServiceAccountKeyEntity
  IosAppCredentialsEntity
  LogRocketOrganizationEntity
  LogRocketProjectEntity
  UserInvitationEntity
  UserPermissionEntity
  WorkerCustomDomainEntity
  WorkerDeploymentAliasEntity
  WorkerEntity
  WorkflowEntity
  WorkflowRevisionEntity
}

type EnvironmentSecret {
  createdAt: DateTime!
  id: ID!
  name: String!
  type: EnvironmentSecretType!
  updatedAt: DateTime!
}

type EnvironmentSecretMutation {
  """Create an environment secret for an Account"""
  createEnvironmentSecretForAccount(accountId: String!, environmentSecretData: CreateEnvironmentSecretInput!): EnvironmentSecret!

  """Create an environment secret for an App"""
  createEnvironmentSecretForApp(appId: String!, environmentSecretData: CreateEnvironmentSecretInput!): EnvironmentSecret!

  """Delete an environment secret"""
  deleteEnvironmentSecret(id: String!): DeleteEnvironmentSecretResult!
}

enum EnvironmentSecretType {
  FILE_BASE64
  STRING
}

type EnvironmentVariable {
  apps: [App!]!
  createdAt: DateTime!
  environments: [EnvironmentVariableEnvironment!]
  fileName: String
  id: ID!
  isGlobal: Boolean
  linkedEnvironments(appFullName: String, appId: String): [EnvironmentVariableEnvironment!]
  name: String!
  scope: EnvironmentVariableScope!
  type: EnvironmentSecretType!
  updatedAt: DateTime!
  value(includeFileContent: Boolean): String
  visibility: EnvironmentVariableVisibility
}

enum EnvironmentVariableEnvironment {
  DEVELOPMENT
  PREVIEW
  PRODUCTION
}

type EnvironmentVariableMutation {
  """Create bulk env variables for an Account"""
  createBulkEnvironmentVariablesForAccount(accountId: ID!, environmentVariablesData: [CreateSharedEnvironmentVariableInput!]!): [EnvironmentVariable!]!

  """Create bulk env variables for an App"""
  createBulkEnvironmentVariablesForApp(appId: ID!, environmentVariablesData: [CreateEnvironmentVariableInput!]!): [EnvironmentVariable!]!

  """Create an environment variable for an Account"""
  createEnvironmentVariableForAccount(accountId: ID!, environmentVariableData: CreateSharedEnvironmentVariableInput!): EnvironmentVariable!

  """Create an environment variable for an App"""
  createEnvironmentVariableForApp(appId: ID!, environmentVariableData: CreateEnvironmentVariableInput!): EnvironmentVariable!

  """Bulk delete environment variables"""
  deleteBulkEnvironmentVariables(ids: [ID!]!): [DeleteEnvironmentVariableResult!]!

  """Delete an environment variable"""
  deleteEnvironmentVariable(id: ID!): DeleteEnvironmentVariableResult!

  """Bulk link shared environment variables"""
  linkBulkSharedEnvironmentVariables(linkData: [LinkSharedEnvironmentVariableInput!]!): [EnvironmentVariable!]!

  """Link shared environment variable"""
  linkSharedEnvironmentVariable(appId: ID!, environment: EnvironmentVariableEnvironment, environmentVariableId: ID!): EnvironmentVariable!

  """Unlink shared environment variable"""
  unlinkSharedEnvironmentVariable(appId: ID!, environment: EnvironmentVariableEnvironment, environmentVariableId: ID!): EnvironmentVariable!

  """Bulk update environment variables"""
  updateBulkEnvironmentVariables(environmentVariablesData: [UpdateEnvironmentVariableInput!]!): [EnvironmentVariable!]!

  """Update an environment variable"""
  updateEnvironmentVariable(environmentVariableData: UpdateEnvironmentVariableInput!): EnvironmentVariable!
}

enum EnvironmentVariableScope {
  PROJECT
  SHARED
}

enum EnvironmentVariableVisibility {
  PUBLIC
  SECRET
  SENSITIVE
}

type EnvironmentVariableWithSecret {
  apps: [App!]!
  createdAt: DateTime!
  environments: [EnvironmentVariableEnvironment!]
  fileName: String
  id: ID!
  isGlobal: Boolean!
  linkedEnvironments(appFullName: String, appId: String): [EnvironmentVariableEnvironment!]
  name: String!
  scope: EnvironmentVariableScope!
  sensitive: Boolean!
  type: EnvironmentSecretType!
  updatedAt: DateTime!
  value(includeFileContent: Boolean): String
  visibility: EnvironmentVariableVisibility!
}

type EstimatedOverageAndCost {
  id: ID!

  """The limit, in units, allowed by this plan"""
  limit: Float!
  metadata: AccountUsageMetadata
  metricType: UsageMetricType!
  service: EASService!
  serviceMetric: EASServiceMetric!

  """Total cost of this particular metric, in cents"""
  totalCost: Int!
  value: Float!
}

type EstimatedUsage {
  id: ID!
  limit: Float!
  metricType: UsageMetricType!
  service: EASService!
  serviceMetric: EASServiceMetric!
  value: Float!
}

enum Experiment {
  ORBIT
}

type ExperimentationQuery {
  """Get device experimentation config"""
  deviceConfig: JSONObject!

  """
  Get experimentation unit to use for device experiments. In this case, it is the IP address.
  """
  deviceExperimentationUnit: ID!

  """Get user experimentation config"""
  userConfig: JSONObject!
}

union FcmSnippet = FcmSnippetLegacy | FcmSnippetV1

type FcmSnippetLegacy {
  firstFourCharacters: String!
  lastFourCharacters: String!
}

type FcmSnippetV1 {
  clientId: String
  keyId: String!
  projectId: String!
  serviceAccountEmail: String!
}

enum Feature {
  """Priority Builds"""
  BUILDS

  """Funds support for open source development"""
  OPEN_SOURCE

  """Top Tier Support"""
  SUPPORT

  """Share access to projects"""
  TEAMS
}

type Fingerprint {
  app: App!
  builds(after: String, before: String, filter: FingerprintBuildsFilterInput, first: Int, last: Int): AppBuildsConnection!
  createdAt: DateTime!
  debugInfoUrl: String
  hash: String!
  id: ID!
  source: FingerprintSource
  updatedAt: DateTime!
  updates(after: String, before: String, first: Int, last: Int): AppUpdatesConnection!
}

input FingerprintBuildsFilterInput {
  channel: String
  developmentClient: Boolean
  distributions: [DistributionType!]
  platforms: [AppPlatform!]
  releaseChannel: String
  simulator: Boolean
}

input FingerprintFilterInput {
  hashes: [String!]
}

input FingerprintInfo {
  fingerprintHash: String!
  fingerprintSource: FingerprintSourceInput!
}

input FingerprintInfoGroup {
  android: FingerprintInfo
  ios: FingerprintInfo
  web: FingerprintInfo
}

type FingerprintMutation {
  """Create or get an existing fingerprint for an App"""
  createOrGetExistingFingerprint(appId: ID!, fingerprintData: CreateFingerprintInput!): Fingerprint!
}

type FingerprintSource {
  bucketKey: String!
  isDebugFingerprint: Boolean
  type: FingerprintSourceType!
}

input FingerprintSourceInput {
  bucketKey: String
  isDebugFingerprint: Boolean
  type: FingerprintSourceType
}

enum FingerprintSourceType {
  GCS
}

type FutureSubscription {
  createdAt: DateTime!
  id: ID!
  meteredBillingStatus: MeteredBillingStatus!
  planId: String!
  recurringCents: Int
  startDate: DateTime!
}

type GenerateLogRocketOrganizationLinkResult {
  url: String!
}

input GenerateLogRocketOrganizationLinkingURLInput {
  accountId: ID!
  callbackUrl: String!
}

type GenerateLogRocketReplayTokenResult {
  orgSlug: String!
  replayToken: String!
}

type GenerateSentryTokenResult {
  installationId: ID!
  orgSlug: String!
  token: String!
}

type GetSignedAssetUploadSpecificationsResult {
  specifications: [String!]!
}

enum GitHubAppEnvironment {
  DEVELOPMENT
  PRODUCTION
  STAGING
}

type GitHubAppInstallation {
  """The Expo account that owns the installation entity."""
  account: Account!
  actor: Actor
  id: ID!
  installationIdentifier: Int!
  metadata: GitHubAppInstallationMetadata!
}

type GitHubAppInstallationAccessibleRepository {
  defaultBranch: String
  description: String
  id: Int!
  name: String!
  nodeId: String!
  owner: GitHubRepositoryOwner!
  private: Boolean!
  url: String!
}

enum GitHubAppInstallationAccountType {
  ORGANIZATION
  USER
}

type GitHubAppInstallationMetadata {
  githubAccountAvatarUrl: String

  """
  The login of the GitHub account that owns the installation. Not the display name.
  """
  githubAccountName: String
  githubAccountType: GitHubAppInstallationAccountType
  installationStatus: GitHubAppInstallationStatus!
}

type GitHubAppInstallationMutation {
  """Create a GitHub App installation for an Account"""
  createGitHubAppInstallationForAccount(githubAppInstallationData: CreateGitHubAppInstallationInput!): GitHubAppInstallation!

  """Delete a GitHub App installation by ID"""
  deleteGitHubAppInstallation(githubAppInstallationId: ID!): GitHubAppInstallation!
}

enum GitHubAppInstallationStatus {
  ACTIVE
  NOT_INSTALLED
  SUSPENDED
}

type GitHubAppMutation {
  """
  Create a GitHub build for an app. Returns the ID of the background job receipt. Use BackgroundJobReceiptQuery to get the status of the job.
  """
  createGitHubBuild(buildInput: GitHubBuildInput!): BackgroundJobReceipt!
}

type GitHubAppQuery {
  appIdentifier: String!
  clientIdentifier: String!
  environment: GitHubAppEnvironment!
  installation(id: ID!): GitHubAppInstallation!
  name: String!
}

input GitHubBuildInput {
  appId: ID!
  autoSubmit: Boolean
  baseDirectory: String
  buildProfile: String!
  environment: EnvironmentVariableEnvironment
  gitRef: String!
  platform: AppPlatform!

  """
  Repack the golden dev client build instead of running full build process. Used for onboarding. Do not use outside of onboarding flow, as for now it's only created with this specific use case in mind.
  """
  repack: Boolean
  submitProfile: String
}

type GitHubBuildTrigger {
  app: App!
  autoSubmit: Boolean!
  buildProfile: String!
  createdAt: DateTime!
  environment: EnvironmentVariableEnvironment
  executionBehavior: GitHubBuildTriggerExecutionBehavior!
  id: ID!
  isActive: Boolean!
  lastRunAt: DateTime
  lastRunBuild: Build
  lastRunErrorCode: String
  lastRunErrorMessage: String
  lastRunStatus: GitHubBuildTriggerRunStatus
  platform: AppPlatform!
  sourcePattern: String!
  submitProfile: String
  targetPattern: String
  type: GitHubBuildTriggerType!
  updatedAt: DateTime!
}

enum GitHubBuildTriggerExecutionBehavior {
  ALWAYS
  BASE_DIRECTORY_CHANGED
}

type GitHubBuildTriggerMutation {
  """Create GitHub build trigger for an App"""
  createGitHubBuildTrigger(githubBuildTriggerData: CreateGitHubBuildTriggerInput!): GitHubBuildTrigger!

  """Delete GitHub build trigger by ID"""
  deleteGitHubBuildTrigger(githubBuildTriggerId: ID!): GitHubBuildTrigger!

  """Update a GitHub build trigger by ID"""
  updateGitHubBuildTrigger(githubBuildTriggerData: UpdateGitHubBuildTriggerInput!, githubBuildTriggerId: ID!): GitHubBuildTrigger!
}

enum GitHubBuildTriggerRunStatus {
  ERRORED
  SUCCESS
}

enum GitHubBuildTriggerType {
  PULL_REQUEST_UPDATED
  PUSH_TO_BRANCH
  TAG_UPDATED
}

enum GitHubJobRunJobType {
  PUBLISH_UPDATE
}

type GitHubJobRunTrigger {
  app: App!
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  jobType: GitHubJobRunJobType
  lastRunAt: DateTime
  lastRunErrorCode: String
  lastRunErrorMessage: String
  lastRunStatus: GitHubJobRunTriggerRunStatus
  sourcePattern: String!
  targetPattern: String
  triggerType: GitHubJobRunTriggerType!
}

type GitHubJobRunTriggerMutation {
  createGitHubJobRunTrigger(gitHubJobRunTriggerData: CreateGitHubJobRunTriggerInput!): GitHubJobRunTrigger!
  deleteGitHubJobRunTrigger(gitHubJobRunTriggerId: ID!): GitHubJobRunTrigger!
  updateGitHubJobRunTrigger(gitHubJobRunTriggerData: UpdateGitHubJobRunTriggerInput!, gitHubJobRunTriggerId: ID!): GitHubJobRunTrigger!
}

enum GitHubJobRunTriggerRunStatus {
  ERRORED
  SUCCESS
}

enum GitHubJobRunTriggerType {
  PULL_REQUEST_UPDATED
  PUSH_TO_BRANCH
}

type GitHubRepository {
  app: App!
  createdAt: DateTime!
  githubAppInstallation: GitHubAppInstallation!
  githubRepositoryIdentifier: Int!
  githubRepositoryUrl: String
  id: ID!
  metadata: GitHubRepositoryMetadata!
  nodeIdentifier: String!
}

type GitHubRepositoryMetadata {
  defaultBranch: String
  githubRepoDescription: String
  githubRepoName: String!
  githubRepoOwnerName: String!
  githubRepoUrl: String!
  lastPushed: DateTime!
  lastUpdated: DateTime!
  private: Boolean!
}

type GitHubRepositoryMutation {
  """
  Configure EAS by pushing a commit to the default branch which updates or creates app.json, eas.json, and installs necessary dependencies.
  """
  configureEAS(githubRepositoryId: ID!): BackgroundJobReceipt!
  createAndConfigureRepository(input: CreateAndConfigureRepositoryInput!): BackgroundJobReceipt!

  """Create a GitHub repository for an App"""
  createGitHubRepository(githubRepositoryData: CreateGitHubRepositoryInput!): GitHubRepository!

  """Delete a GitHub repository by ID"""
  deleteGitHubRepository(githubRepositoryId: ID!): GitHubRepository!
}

type GitHubRepositoryOwner {
  avatarUrl: String!
  id: Int!
  login: String!
  url: String!
}

type GitHubRepositoryPaginationResult {
  repositories: [GitHubAppInstallationAccessibleRepository!]!
  totalCount: Int!
}

type GitHubRepositorySettings {
  app: App!
  baseDirectory: String!
  id: ID!
}

type GitHubRepositorySettingsMutation {
  """Create GitHub repository settings for an App"""
  createGitHubRepositorySettings(githubRepositorySettingsData: CreateGitHubRepositorySettingsInput!): GitHubRepositorySettings!

  """Delete GitHub repository settings by ID"""
  deleteGitHubRepositorySettings(githubRepositorySettingsId: ID!): GitHubRepositorySettings!

  """Update GitHub repository settings"""
  updateGitHubRepositorySettings(githubRepositorySettingsData: UpdateGitHubRepositorySettingsInput!, githubRepositorySettingsId: ID!): GitHubRepositorySettings!
}

type GitHubUser {
  githubUserIdentifier: String!
  id: ID!
  metadata: GitHubUserMetadata
  userActor: UserActor!
}

type GitHubUserMetadata {
  avatarUrl: String!
  login: String!
  name: String
  url: String!
}

type GitHubUserMutation {
  """Delete a GitHub User by ID"""
  deleteGitHubUser(id: ID!): DeleteGitHubUserResult!

  """Generate a GitHub User Access Token"""
  generateGitHubUserAccessToken: String
}

type GoogleServiceAccountKey {
  account: Account!
  clientEmail: String!
  clientIdentifier: String!
  createdAt: DateTime!
  id: ID!
  keyJson: String!
  privateKeyIdentifier: String!
  projectIdentifier: String!
  updatedAt: DateTime!
}

input GoogleServiceAccountKeyInput {
  jsonKey: JSONObject!
}

type GoogleServiceAccountKeyMutation {
  """Create a Google Service Account Key"""
  createGoogleServiceAccountKey(accountId: ID!, googleServiceAccountKeyInput: GoogleServiceAccountKeyInput!): GoogleServiceAccountKey!

  """Delete a Google Service Account Key"""
  deleteGoogleServiceAccountKey(id: ID!): DeleteGoogleServiceAccountKeyResult!
}

type GoogleServiceAccountKeyQuery {
  byId(id: ID!): GoogleServiceAccountKey!
}

"""
The value field is always sent from the client as a string,
and then it's parsed server-side according to the filterType
"""
input InsightsFilter {
  filterType: InsightsFilterType!
  value: String!
}

enum InsightsFilterType {
  PLATFORM
}

input InsightsTimespan {
  end: DateTime!
  start: DateTime!
}

type Invoice {
  """The total amount due for the invoice, in cents"""
  amountDue: Int!

  """
  The total amount that has been paid, considering any discounts or account credit. Value is in cents.
  """
  amountPaid: Int!

  """
  The total amount that needs to be paid, considering any discounts or account credit. Value is in cents.
  """
  amountRemaining: Int!
  discount: InvoiceDiscount
  id: ID!
  lineItems: [InvoiceLineItem!]!
  period: InvoicePeriod!
  startingBalance: Int!
  subtotal: Int!
  total: Int!
  totalDiscountedAmount: Int!
}

type InvoiceDiscount {
  """The coupon's discount value, in percentage or in dollar amount"""
  amount: Int!
  duration: String!
  durationInMonths: Int
  id: ID!
  name: String!
  type: InvoiceDiscountType!
}

enum InvoiceDiscountType {
  AMOUNT
  PERCENTAGE
}

type InvoiceLineItem {
  """Line-item amount in cents"""
  amount: Int!
  description: String!
  id: ID!
  metadata: JSONObject!
  period: InvoicePeriod!
  plan: InvoiceLineItemPlan! @deprecated(reason: "Use 'price' instead")
  price: StripePrice
  proration: Boolean!
  quantity: Int!

  """The unit amount excluding tax, in cents"""
  unitAmountExcludingTax: Float
}

type InvoiceLineItemPlan {
  id: ID!
  name: String
}

type InvoicePeriod {
  end: DateTime!
  start: DateTime!
}

type InvoiceQuery {
  """
  Previews the invoice for the specified number of additional concurrencies.
  This is the total number of concurrencies the customer wishes to purchase
  on top of their base plan, not the relative change in concurrencies
  the customer wishes to make. For example, specify "3" if the customer has
  two add-on concurrencies and wishes to purchase one more.
  """
  previewInvoiceForAdditionalConcurrenciesCountUpdate(accountID: ID!, additionalConcurrenciesCount: Int!): Invoice

  """Preview an upgrade subscription invoice, with proration"""
  previewInvoiceForSubscriptionUpdate(accountId: String!, couponCode: String, newPlanIdentifier: String!): Invoice!
}

type IosAppBuildCredentials {
  appleDevices: [AppleDevice] @deprecated(reason: "Get Apple Devices from AppleProvisioningProfile instead")
  distributionCertificate: AppleDistributionCertificate
  id: ID!
  iosAppCredentials: IosAppCredentials!
  iosDistributionType: IosDistributionType!
  provisioningProfile: AppleProvisioningProfile
}

input IosAppBuildCredentialsFilter {
  iosDistributionType: IosDistributionType
}

input IosAppBuildCredentialsInput {
  distributionCertificateId: ID!
  iosDistributionType: IosDistributionType!
  provisioningProfileId: ID!
}

type IosAppBuildCredentialsMutation {
  """Create a set of build credentials for an iOS app"""
  createIosAppBuildCredentials(iosAppBuildCredentialsInput: IosAppBuildCredentialsInput!, iosAppCredentialsId: ID!): IosAppBuildCredentials!

  """Disassociate the build credentials from an iOS app"""
  deleteIosAppBuildCredentials(id: ID!): DeleteIosAppBuildCredentialsResult!

  """Set the distribution certificate to be used for an iOS app"""
  setDistributionCertificate(distributionCertificateId: ID!, id: ID!): IosAppBuildCredentials!

  """Set the provisioning profile to be used for an iOS app"""
  setProvisioningProfile(id: ID!, provisioningProfileId: ID!): IosAppBuildCredentials!
}

type IosAppCredentials {
  app: App!
  appStoreConnectApiKeyForBuilds: AppStoreConnectApiKey
  appStoreConnectApiKeyForSubmissions: AppStoreConnectApiKey
  appleAppIdentifier: AppleAppIdentifier!
  appleTeam: AppleTeam
  id: ID!
  iosAppBuildCredentialsArray(filter: IosAppBuildCredentialsFilter): [IosAppBuildCredentials!]! @deprecated(reason: "use iosAppBuildCredentialsList instead")
  iosAppBuildCredentialsList(filter: IosAppBuildCredentialsFilter): [IosAppBuildCredentials!]!
  pushKey: ApplePushKey
}

input IosAppCredentialsFilter {
  appleAppIdentifierId: String
}

input IosAppCredentialsInput {
  appStoreConnectApiKeyForBuildsId: ID
  appStoreConnectApiKeyForSubmissionsId: ID
  appleTeamId: ID
  pushKeyId: ID
}

type IosAppCredentialsMutation {
  """Create a set of credentials for an iOS app"""
  createIosAppCredentials(appId: ID!, appleAppIdentifierId: ID!, iosAppCredentialsInput: IosAppCredentialsInput!): IosAppCredentials!

  """Delete a set of credentials for an iOS app"""
  deleteIosAppCredentials(id: ID!): DeleteIosAppCredentialsResult!

  """Set the App Store Connect Api Key to be used for submitting an iOS app"""
  setAppStoreConnectApiKeyForSubmissions(ascApiKeyId: ID!, id: ID!): IosAppCredentials!

  """Set the push key to be used in an iOS app"""
  setPushKey(id: ID!, pushKeyId: ID!): IosAppCredentials!

  """Update a set of credentials for an iOS app"""
  updateIosAppCredentials(id: ID!, iosAppCredentialsInput: IosAppCredentialsInput!): IosAppCredentials!
}

"""@deprecated Use developmentClient option instead."""
enum IosBuildType {
  DEVELOPMENT_CLIENT
  RELEASE
}

input IosBuilderEnvironmentInput {
  bun: String
  bundler: String
  cocoapods: String
  corepack: Boolean
  env: JSONObject
  expoCli: String
  fastlane: String
  image: String
  node: String
  pnpm: String
  yarn: String
}

enum IosDistributionType {
  AD_HOC
  APP_STORE
  DEVELOPMENT
  ENTERPRISE
}

input IosJobDistributionCertificateInput {
  dataBase64: String!
  password: String!
}

input IosJobInput {
  applicationArchivePath: String

  """@deprecated"""
  artifactPath: String
  buildArtifactPaths: [String!]
  buildConfiguration: String
  buildProfile: String

  """@deprecated"""
  buildType: IosBuildType
  builderEnvironment: IosBuilderEnvironmentInput
  cache: BuildCacheInput
  customBuildConfig: CustomBuildConfigInput
  developmentClient: Boolean

  """@deprecated"""
  distribution: DistributionType
  environment: EnvironmentVariableEnvironment
  experimental: JSONObject
  loggerLevel: WorkerLoggerLevel
  mode: BuildMode
  projectArchive: ProjectArchiveSourceInput!
  projectRootDirectory: String!
  releaseChannel: String
  scheme: String
  secrets: IosJobSecretsInput
  simulator: Boolean
  triggeredBy: BuildTrigger
  type: BuildWorkflow!
  updates: BuildUpdatesInput
  username: String
  version: IosJobVersionInput
}

input IosJobOverridesInput {
  applicationArchivePath: String

  """@deprecated"""
  artifactPath: String
  buildArtifactPaths: [String!]
  buildConfiguration: String
  buildProfile: String

  """@deprecated"""
  buildType: IosBuildType
  builderEnvironment: IosBuilderEnvironmentInput
  cache: BuildCacheInput
  customBuildConfig: CustomBuildConfigInput
  developmentClient: Boolean

  """@deprecated"""
  distribution: DistributionType
  experimental: JSONObject
  loggerLevel: WorkerLoggerLevel
  mode: BuildMode
  releaseChannel: String
  resign: BuildResignInput
  scheme: String
  secrets: IosJobSecretsInput
  simulator: Boolean
  type: BuildWorkflow
  updates: BuildUpdatesInput
  username: String
  version: IosJobVersionInput
}

input IosJobSecretsInput {
  buildCredentials: [IosJobTargetCredentialsInput]
  robotAccessToken: String
}

input IosJobTargetCredentialsInput {
  distributionCertificate: IosJobDistributionCertificateInput!
  provisioningProfileBase64: String!
  targetName: String!
}

input IosJobVersionInput {
  buildNumber: String!
}

"""@deprecated Use developmentClient option instead."""
enum IosManagedBuildType {
  DEVELOPMENT_CLIENT
  RELEASE
}

enum IosSchemeBuildConfiguration {
  DEBUG
  RELEASE
}

type IosSubmissionConfig {
  appleIdUsername: String
  ascApiKeyId: String
  ascAppIdentifier: String!
}

input IosSubmissionConfigInput {
  appleAppSpecificPassword: String
  appleIdUsername: String
  archiveUrl: String
  ascApiKey: AscApiKeyInput
  ascApiKeyId: String
  ascAppIdentifier: String!
  groups: [String!]
  isVerboseFastlaneEnabled: Boolean
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""Represents a Turtle Job Run"""
type JobRun {
  app: App!
  artifacts: [WorkflowArtifact!]!
  childJobRun: JobRun @deprecated
  createdAt: DateTime!
  displayName: String
  endedAt: DateTime
  errors: [JobRunError!]!
  expiresAt: DateTime!
  gitCommitHash: String
  gitCommitMessage: String
  gitRef: String
  id: ID!
  initiatingActor: Actor
  isWaived: Boolean!
  logFileUrls: [String!]!
  name: String!
  priority: JobRunPriority!
  startedAt: DateTime
  status: JobRunStatus!
  updateGroups: [[Update!]!]!
}

type JobRunError {
  buildPhase: String
  docsUrl: String
  errorCode: String!
  message: String!
}

type JobRunMutation {
  """Cancel an EAS Job Run"""
  cancelJobRun(jobRunId: ID!): JobRun!
}

enum JobRunPriority {
  HIGH
  NORMAL
}

type JobRunQuery {
  """Look up EAS Job Run by ID"""
  byId(jobRunId: ID!): JobRun!
}

enum JobRunStatus {
  CANCELED
  ERRORED
  FINISHED
  IN_PROGRESS
  IN_QUEUE
  NEW
  PENDING_CANCEL
}

type KeystoreGenerationUrl {
  id: ID!
  url: String!
}

type KeystoreGenerationUrlMutation {
  """Create a Keystore Generation URL"""
  createKeystoreGenerationUrl: KeystoreGenerationUrl!
}

type LatestUpdateOnBranch {
  branchId: String!
  update: Update
}

type LeaveAccountResult {
  success: Boolean!
}

type LineChartData {
  datasets: [LineDataset!]!
  labels: [String!]!
}

type LineDatapoint {
  data: Int!
  id: ID!
  label: String!
}

type LineDataset {
  data: [Int]!
  id: ID!
  label: String!
}

input LinkLogRocketOrganizationToExpoAccountInput {
  accountId: ID!
  client_id: String!
  client_secret: String!
  orgName: String!
  orgSlug: String!
  state: String!
}

input LinkSentryInstallationToExpoAccountInput {
  accountId: ID!
  code: String!
  installationId: ID!
  sentryOrgSlug: String!
}

input LinkSharedEnvironmentVariableInput {
  appId: ID!
  environment: EnvironmentVariableEnvironment
  environmentVariableId: ID!
}

input LocalBuildArchiveSourceInput {
  bucketKey: String!
  type: LocalBuildArchiveSourceType!
}

enum LocalBuildArchiveSourceType {
  GCS
}

input LocalBuildJobInput {
  developmentClient: Boolean
  platform: AppPlatform!
  simulator: Boolean
}

type LogNameTypeMapping {
  publicName: String!
  typeName: EntityTypeName!
}

type LogRocketOrganization {
  account: Account!
  createdAt: DateTime!
  id: ID!
  orgName: String!
  orgSlug: String!
}

type LogRocketOrganizationMutation {
  """Delete a LogRocket organization by ID"""
  deleteLogRocketOrganization(accountId: ID!): DeleteLogRocketOrganizationResult!

  """Generate a LogRocket linking URL"""
  generateLogRocketOrganizationLinkingURL(input: GenerateLogRocketOrganizationLinkingURLInput!): GenerateLogRocketOrganizationLinkResult!

  """Generate a LogRocket replay token for an organization"""
  generateLogRocketReplayToken(accountId: ID!): GenerateLogRocketReplayTokenResult!

  """Link a LogRocket organization to an Expo account"""
  linkLogRocketOrganizationToExpoAccount(input: LinkLogRocketOrganizationToExpoAccountInput!): LogRocketOrganization!
}

type LogRocketProject {
  app: App!
  createdAt: DateTime!
  id: ID!
  logRocketOrgId: ID!
  logRocketProjectSlug: String!
  updatedAt: DateTime!
}

type LogRocketProjectMutation {
  """Create a LogRocket project"""
  createLogRocketProject(appId: ID!, logRocketProjectSlug: String!): LogRocketProject!

  """Delete a LogRocket project by ID"""
  deleteLogRocketProject(logRocketProjectId: ID!): DeleteLogRocketProjectResult!
}

input LogsTimespan {
  end: DateTime!
  start: DateTime
}

enum MailchimpAudience {
  EXPO_DEVELOPERS
  EXPO_DEVELOPER_ONBOARDING
  LAUNCH_PARTY_2024
  NONPROD_EXPO_DEVELOPERS
}

enum MailchimpTag {
  DEV_CLIENT_USERS
  DID_SUBSCRIBE_TO_EAS_AT_LEAST_ONCE
  EAS_MASTER_LIST
  NEWSLETTER_SIGNUP_LIST
}

type MailchimpTagPayload {
  id: Int
  name: String
}

type MeMutation {
  """Add an additional second factor device"""
  addSecondFactorDevice(deviceConfiguration: SecondFactorDeviceConfiguration!, otp: String): SecondFactorDeviceConfigurationResult!

  """
  Certify an initiated second factor authentication method for the current user
  """
  certifySecondFactorDevice(otp: String!): SecondFactorBooleanResult!

  """Create a new Account and grant this User the owner Role"""
  createAccount(accountData: AccountDataInput!): Account!

  """Delete a second factor device"""
  deleteSecondFactorDevice(otp: String, userSecondFactorDeviceId: ID!): SecondFactorBooleanResult!

  """Delete a Snack that the current user owns"""
  deleteSnack(snackId: ID!): Snack!

  """Disable all second factor authentication for the current user"""
  disableSecondFactorAuthentication(otp: String): SecondFactorBooleanResult!

  """Initiate setup of two-factor authentication for the current user"""
  initiateSecondFactorAuthentication(deviceConfigurations: [SecondFactorDeviceConfiguration!]!, recaptchaResponseToken: String): SecondFactorInitiationResult!

  """Leave an Account (revoke own permissions on Account)"""
  leaveAccount(accountId: ID!): LeaveAccountResult!

  """
  Purge unfinished two-factor authentication setup for the current user if not fully-set-up
  """
  purgeUnfinishedSecondFactorAuthentication: SecondFactorBooleanResult!

  """Regenerate backup codes for the current user"""
  regenerateSecondFactorBackupCodes(otp: String): SecondFactorRegenerateBackupCodesResult!

  """Schedule deletion for Account created via createAccount"""
  scheduleAccountDeletion(accountId: ID!): BackgroundJobReceipt!

  """Schedule deletion of the current regular user"""
  scheduleCurrentUserDeletion: BackgroundJobReceipt!

  """
  Schedule deletion of a SSO user. Actor must be an owner on the SSO user's SSO account.
  """
  scheduleSSOUserDeletionAsSSOAccountOwner(ssoUserId: ID!): BackgroundJobReceipt!

  """
  Send SMS OTP to a second factor device for use during device setup or during change confirmation
  """
  sendSMSOTPToSecondFactorDevice(userSecondFactorDeviceId: ID!): SecondFactorBooleanResult!

  """
  Sets user preferences. This is a key-value store for user-specific settings. Provided values are
  key-level merged with existing values.
  """
  setPreferences(preferences: UserPreferencesInput!): UserPreferences!

  """Set the user's primary second factor device"""
  setPrimarySecondFactorDevice(userSecondFactorDeviceId: ID!): SecondFactorBooleanResult!

  """Transfer project to a different Account"""
  transferApp(appId: ID!, destinationAccountId: ID!): App!

  """Update an App that the current user owns"""
  updateApp(appData: AppDataInput!): App!

  """Update the current regular user's data"""
  updateProfile(userData: UserDataInput!): User!

  """Update the current SSO user's data"""
  updateSSOProfile(userData: SSOUserDataInput!): SSOUser!
}

type MeteredBillingStatus {
  EAS_BUILD: Boolean!
  EAS_UPDATE: Boolean!
}

type Notification {
  accountName: String!
  createdAt: DateTime!
  event: NotificationEvent!
  id: ID!
  isRead: Boolean!
  metadata: NotificationMetadata
  type: NotificationType!
  updatedAt: DateTime!
  websiteMessage: String!
}

enum NotificationEvent {
  BUILD_COMPLETE
  BUILD_ERRORED
  BUILD_LIMIT_THRESHOLD_EXCEEDED
  BUILD_PLAN_CREDIT_THRESHOLD_EXCEEDED
  SUBMISSION_COMPLETE
  SUBMISSION_ERRORED
  TEST
}

union NotificationMetadata = BuildLimitThresholdExceededMetadata | BuildPlanCreditThresholdExceededMetadata | TestNotificationMetadata

type NotificationSubscription {
  account: Account
  actor: Actor
  app: App
  createdAt: DateTime!
  event: NotificationEvent!
  id: ID!
  type: NotificationType!
}

input NotificationSubscriptionFilter {
  accountId: ID
  appId: ID
  event: NotificationEvent
  type: NotificationType
}

type NotificationSubscriptionMutation {
  subscribeToEventForAccount(input: AccountNotificationSubscriptionInput!): SubscribeToNotificationResult!
  subscribeToEventForApp(input: AppNotificationSubscriptionInput!): SubscribeToNotificationResult!
  unsubscribe(id: ID!): UnsubscribeFromNotificationResult!
}

type NotificationThresholdExceeded {
  count: Int!
  limit: Int!
  threshold: Int!
  type: BuildLimitThresholdExceededMetadataType!
}

enum NotificationType {
  EMAIL
  WEB
}

type NotificationsSentOverTimeData {
  data: LineChartData!
}

type Offer {
  features: [Feature]
  id: ID!
  prerequisite: OfferPrerequisite
  price: Int!
  quantity: Int
  stripeId: ID!
  trialLength: Int
  type: OfferType!
}

type OfferPrerequisite {
  stripeIds: [String!]!
  type: String!
}

enum OfferType {
  """Addon, or supplementary subscription"""
  ADDON

  """Advanced Purchase of Paid Resource"""
  PREPAID

  """Term subscription"""
  SUBSCRIPTION
}

enum OnboardingDeviceType {
  DEVICE
  SIMULATOR
}

enum OnboardingEnvironment {
  DEV_BUILD
  EXPO_GO
}

enum Order {
  ASC
  DESC
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PartialManifest {
  assets: [PartialManifestAsset]!
  extra: JSONObject
  launchAsset: PartialManifestAsset!
}

input PartialManifestAsset {
  bundleKey: String!
  contentType: String!
  fileExtension: String
  fileSHA256: String!
  storageKey: String!
}

type PaymentDetails {
  address: Address
  card: Card
  id: ID!
}

type PendingSentryInstallation {
  account: Account!
  createdAt: DateTime!
  id: ID!
  installationId: String!
  orgSlug: String!
}

enum Permission {
  ADMIN
  OWN
  PUBLISH
  VIEW
}

union PlanEnablement = Concurrencies | EASTotalPlanEnablement

interface Project {
  description: String!
  fullName: String!
  iconUrl: String @deprecated
  id: ID!
  name: String!
  published: Boolean!
  slug: String!
  updated: DateTime!
  username: String!
}

input ProjectArchiveSourceInput {
  bucketKey: String
  gitRef: String
  metadataLocation: String
  repositoryUrl: String
  type: ProjectArchiveSourceType!
  url: String
}

enum ProjectArchiveSourceType {
  GCS
  GIT
  NONE
  URL
}

type ProjectPublicData {
  fullName: String!
  id: ID!
}

type ProjectQuery {
  byUsernameAndSlug(platform: String, sdkVersions: [String], slug: String!, username: String!): Project! @deprecated(reason: "See byAccountNameAndSlug")
}

type PublicArtifacts {
  applicationArchiveUrl: String
  buildUrl: String
}

input PublishUpdateGroupInput {
  assetMapGroup: AssetMapGroup
  awaitingCodeSigningInfo: Boolean
  branchId: String!
  environment: EnvironmentVariableEnvironment
  excludedAssets: [PartialManifestAsset!]
  fingerprintInfoGroup: FingerprintInfoGroup
  gitCommitHash: String
  isGitWorkingTreeDirty: Boolean
  message: String
  rollBackToEmbeddedInfoGroup: UpdateRollBackToEmbeddedGroup
  rolloutInfoGroup: UpdateRolloutInfoGroup
  runtimeVersion: String!
  turtleJobRunId: String
  updateInfoGroup: UpdateInfoGroup
}

enum RequestMethod {
  DELETE
  GET
  HEAD
  OPTIONS
  PATCH
  POST
  PUT
}

input RequestsFilters {
  cacheStatus: [ResponseCacheStatus!]
  continent: [ContinentCode!]
  country: [String!]
  hasCustomDomainOrigin: Boolean
  isAsset: Boolean
  isCrash: Boolean
  isLimitExceeded: Boolean
  isVerifiedBot: Boolean
  method: [RequestMethod!]
  os: [UserAgentOS!]
  pathname: String
  platform: [UserAgentPlatform!]
  requestId: [WorkerDeploymentRequestID!]
  responseType: [ResponseType!]
  status: [Int!]
  statusType: [ResponseStatusType!]
}

input RequestsOrderBy {
  direction: RequestsOrderByDirection
  field: RequestsOrderByField!
}

enum RequestsOrderByDirection {
  ASC
  DESC
}

enum RequestsOrderByField {
  ASSETS_SUM
  CACHE_HIT_RATIO
  CACHE_PASS_RATIO
  CRASHES_SUM
  DURATION
  REQUESTS_SUM
}

type RescindUserInvitationResult {
  id: ID!
}

enum ResourceClassExperiment {
  C3D
  N2
}

enum ResponseCacheStatus {
  HIT
  MISS
  PASS
}

enum ResponseStatusType {
  CLIENT_ERROR
  NONE
  REDIRECT
  SERVER_ERROR
  SUCCESSFUL
}

enum ResponseType {
  ASSET
  CRASH
  REJECTED
  ROUTE
}

"""Represents a robot (not human) actor."""
type Robot implements Actor {
  """Access Tokens belonging to this actor"""
  accessTokens: [AccessToken!]!

  """Associated accounts"""
  accounts: [Account!]!
  created: DateTime!
  displayName: String!

  """Experiments associated with this actor"""
  experiments: [ActorExperiment!]!

  """
  Server feature gate values for this actor, optionally filtering by desired gates.
  Only resolves for the viewer.
  """
  featureGates(filter: [String!]): JSONObject!
  firstName: String

  """GitHub App Installations that manage this actor"""
  githubAppInstallations: [GitHubAppInstallation!]!
  id: ID!
  isExpoAdmin: Boolean!
  isManagedByGitHubApp: Boolean!
  lastDeletionAttemptTime: DateTime
}

input RobotDataInput {
  name: String
}

type RobotMutation {
  """Create a Robot and grant it Permissions on an Account"""
  createRobotForAccount(accountID: String!, permissions: [Permission]!, robotData: RobotDataInput): Robot!

  """Schedule deletion of a Robot"""
  scheduleRobotDeletion(id: ID!): BackgroundJobReceipt!

  """Update a Robot"""
  updateRobot(id: String!, robotData: RobotDataInput!): Robot!
}

enum Role {
  ADMIN
  CUSTOM
  DEVELOPER
  HAS_ADMIN
  NOT_ADMIN
  OWNER
  VIEW_ONLY
}

type RootMutation {
  """This is a placeholder field"""
  _doNotUse: String @deprecated(reason: "Not used.")

  """
  Mutations that create, read, update, and delete AccessTokens for Actors
  """
  accessToken: AccessTokenMutation!

  """Mutations that modify an Account"""
  account(accountName: ID): AccountMutation!

  """Mutations that create, update, and delete an AccountSSOConfiguration"""
  accountSSOConfiguration: AccountSSOConfigurationMutation!

  """Mutations for Actor experiments"""
  actorExperiment: ActorExperimentMutation!

  """Mutations that modify the build credentials for an Android app"""
  androidAppBuildCredentials: AndroidAppBuildCredentialsMutation!

  """Mutations that modify the credentials for an Android app"""
  androidAppCredentials: AndroidAppCredentialsMutation!

  """Mutations that modify an FCM V0/Legacy credential"""
  androidFcm: AndroidFcmMutation!

  """Mutations that modify a Keystore"""
  androidKeystore: AndroidKeystoreMutation!

  """Mutations that modify an App"""
  app(appId: ID): AppMutation

  """Mutations that modify an App Store Connect Api Key"""
  appStoreConnectApiKey: AppStoreConnectApiKeyMutation!

  """Mutations that modify an AppVersion"""
  appVersion: AppVersionMutation!

  """Mutations that modify an Identifier for an iOS App"""
  appleAppIdentifier: AppleAppIdentifierMutation!

  """Mutations that modify an Apple Device"""
  appleDevice: AppleDeviceMutation!

  """Mutations that modify an Apple Device registration request"""
  appleDeviceRegistrationRequest: AppleDeviceRegistrationRequestMutation!

  """Mutations that modify a Distribution Certificate"""
  appleDistributionCertificate: AppleDistributionCertificateMutation!

  """Mutations that modify a Provisioning Profile"""
  appleProvisioningProfile: AppleProvisioningProfileMutation!

  """Mutations that modify an Apple Push Notification key"""
  applePushKey: ApplePushKeyMutation!

  """Mutations that modify an Apple Team"""
  appleTeam: AppleTeamMutation!
  asset: AssetMutation!
  auditLog: AuditLogMutation!

  """Mutations that modify an EAS Build"""
  build(buildId: ID): BuildMutation!

  """Mutations that create, update, and delete Build Annotations"""
  buildAnnotation: BuildAnnotationMutation!
  customDomain: CustomDomainMutation!
  deployments: DeploymentsMutation!

  """Mutations that assign or modify DevDomainNames for apps"""
  devDomainName: AppDevDomainNameMutation!

  """Mutations for Discord users"""
  discordUser: DiscordUserMutation!

  """Mutations that modify an EmailSubscription"""
  emailSubscription: EmailSubscriptionMutation!

  """Mutations that create and delete EnvironmentSecrets"""
  environmentSecret: EnvironmentSecretMutation!

  """Mutations that create and delete EnvironmentVariables"""
  environmentVariable: EnvironmentVariableMutation!

  """Mutations that modify App fingerprints"""
  fingerprint: FingerprintMutation!

  """Mutations that utilize services facilitated by the GitHub App"""
  githubApp: GitHubAppMutation!

  """Mutations for GitHub App installations"""
  githubAppInstallation: GitHubAppInstallationMutation!

  """Mutations for GitHub build triggers"""
  githubBuildTrigger: GitHubBuildTriggerMutation!
  githubJobRunTrigger: GitHubJobRunTriggerMutation!

  """Mutations for GitHub repositories"""
  githubRepository: GitHubRepositoryMutation!

  """Mutations for GitHub repository settings"""
  githubRepositorySettings: GitHubRepositorySettingsMutation!

  """Mutations for GitHub users"""
  githubUser: GitHubUserMutation!

  """Mutations that modify a Google Service Account Key"""
  googleServiceAccountKey: GoogleServiceAccountKeyMutation!

  """Mutations that modify the build credentials for an iOS app"""
  iosAppBuildCredentials: IosAppBuildCredentialsMutation!

  """Mutations that modify the credentials for an iOS app"""
  iosAppCredentials: IosAppCredentialsMutation!

  """Mutations that modify an EAS Build"""
  jobRun: JobRunMutation!
  keystoreGenerationUrl: KeystoreGenerationUrlMutation!

  """Mutations for LogRocket organizations"""
  logRocketOrganization: LogRocketOrganizationMutation!

  """Mutations for LogRocket projects"""
  logRocketProject: LogRocketProjectMutation!

  """Mutations that modify the currently authenticated User"""
  me: MeMutation!

  """Mutations that modify a NotificationSubscription"""
  notificationSubscription: NotificationSubscriptionMutation!

  """Mutations that create, update, and delete Robots"""
  robot: RobotMutation!

  """Mutations for Sentry installations"""
  sentryInstallation: SentryInstallationMutation!

  """Mutations for Sentry projects"""
  sentryProject: SentryProjectMutation!

  """Mutations that modify an EAS Submit submission"""
  submission: SubmissionMutation!
  update: UpdateMutation!
  updateBranch: UpdateBranchMutation!
  updateChannel: UpdateChannelMutation!
  uploadSession: UploadSession!

  """Mutations that create, update, and delete pinned apps"""
  userAppPins: UserAppPinMutation!
  userAuditLog: UserAuditLogMutation!

  """Mutations that create, delete, and accept UserInvitations"""
  userInvitation: UserInvitationMutation!

  """Mutations that create, delete, update Webhooks"""
  webhook: WebhookMutation!

  """Mutations that modify a websiteNotification"""
  websiteNotifications: WebsiteNotificationMutation!
  workflowJob: WorkflowJobMutation!
  workflowRevision: WorkflowRevisionMutation!
  workflowRun: WorkflowRunMutation!
}

type RootQuery {
  """This is a placeholder field"""
  _doNotUse: String @deprecated(reason: "Not used.")

  """Top-level query object for querying Accounts."""
  account: AccountQuery!

  """Top-level query object for querying AccountSSOConfigurationPublicData"""
  accountSSOConfigurationPublicData: AccountSSOConfigurationPublicDataQuery!

  """Top-level query object for querying Actors."""
  actor: ActorQuery! @deprecated(reason: "Public actor queries are no longer supported")

  """Public apps in the app directory"""
  allPublicApps(
    """Filter to use to filter public app list"""
    filter: AppsFilter!
    limit: Int
    offset: Int

    """Method to sort by"""
    sort: AppSort!
  ): [App] @deprecated(reason: "Use 'all' field under 'app'.")
  app: AppQuery!

  """Look up app by app id"""
  appByAppId(appId: String!): App @deprecated(reason: "Use 'byId' field under 'app'.")

  """Top-level query object for querying App Store Connect API Keys."""
  appStoreConnectApiKey: AppStoreConnectApiKeyQuery!

  """
  Top-level query object for querying Apple Device registration requests.
  """
  appleDeviceRegistrationRequest: AppleDeviceRegistrationRequestQuery!

  """Top-level query object for querying Apple Teams."""
  appleTeam: AppleTeamQuery!
  asset: AssetQuery!

  """Top-level query object for querying Account Audit Logs."""
  auditLogs: AuditLogQuery!
  backgroundJobReceipt: BackgroundJobReceiptQuery!

  """Top-level query object for querying Branchs."""
  branches: BranchQuery!

  """Top-level query object for querying annotations."""
  buildAnnotations: BuildAnnotationsQuery!

  """Top-level query object for querying BuildPublicData publicly."""
  buildPublicData: BuildPublicDataQuery!
  builds: BuildQuery!

  """Top-level query object for querying Channels."""
  channels: ChannelQuery!

  """Top-level query object for querying Deployments."""
  deployments: DeploymentQuery!

  """Top-level query object for querying Experimentation configuration."""
  experimentation: ExperimentationQuery!

  """
  Top-level query object for querying GitHub App information and resources it has access to.
  """
  githubApp: GitHubAppQuery!

  """Top-level query object for querying Google Service Account Keys."""
  googleServiceAccountKey: GoogleServiceAccountKeyQuery!

  """Top-level query object for querying Stripe Invoices."""
  invoice: InvoiceQuery!
  jobRun: JobRunQuery!

  """
  If authenticated as a typical end user, this is the appropriate top-level
  query object
  """
  me: User

  """
  If authenticated as any type of Actor, this is the appropriate top-level
  query object
  """
  meActor: Actor

  """
  If authenticated as any type of human end user (Actor types User or SSOUser),
  this is the appropriate top-level query object
  """
  meUserActor: UserActor
  project: ProjectQuery! @deprecated(reason: "Snacks and apps should be queried separately")

  """Top-level query object for querying Runtimes."""
  runtimes: RuntimeQuery!
  snack: SnackQuery!

  """Top-level query object for querying Expo status page services."""
  statuspageService: StatuspageServiceQuery!
  submissions: SubmissionQuery!

  """Top-level query object for querying Updates."""
  updates: UpdateQuery!

  """fetch all updates in a group"""
  updatesByGroup(group: ID!, platform: String): [Update!]!

  """Top-level query object for querying Users."""
  user: UserQuery! @deprecated(reason: "Public user queries are no longer supported")

  """Top-level query object for querying UserActors."""
  userActor: UserActorQuery! @deprecated(reason: "Public user queries are no longer supported")

  """Top-level query object for querying UserActorPublicData publicly."""
  userActorPublicData: UserActorPublicDataQuery!

  """Top-level query object for querying User Audit Logs."""
  userAuditLogs: UserAuditLogQuery!
  userByUserId(userId: String!): User @deprecated(reason: "Use 'byId' field under 'user'.")
  userByUsername(username: String!): User @deprecated(reason: "Use 'byUsername' field under 'user'.")

  """Top-level query object for querying UserInvitationPublicData publicly."""
  userInvitationPublicData: UserInvitationPublicDataQuery!

  """
  If authenticated as a typical end user, this is the appropriate top-level
  query object
  """
  viewer: User

  """Top-level query object for querying Webhooks."""
  webhook: WebhookQuery!
  workerDeployment: WorkerDeploymentQuery!
  workflowJobs: WorkflowJobQuery!
  workflowRevisions: WorkflowRevisionQuery!
  workflowRuns: WorkflowRunQuery!
  workflows: WorkflowQuery!
}

type Runtime {
  app: App!
  builds(after: String, before: String, filter: RuntimeBuildsFilterInput, first: Int, last: Int): AppBuildsConnection!
  createdAt: DateTime!
  deployments(after: String, before: String, filter: RuntimeDeploymentsFilterInput, first: Int, last: Int): DeploymentsConnection!
  fingerprint: Fingerprint
  firstBuildCreatedAt: DateTime
  id: ID!
  isFingerprint: Boolean!
  updatedAt: DateTime!
  updates(after: String, before: String, first: Int, last: Int): AppUpdatesConnection!
  version: String!
}

input RuntimeBuildsFilterInput {
  channel: String
  developmentClient: Boolean
  distributions: [DistributionType!]
  platforms: [AppPlatform!]
  releaseChannel: String
  simulator: Boolean
}

input RuntimeDeploymentsFilterInput {
  channel: String
}

type RuntimeEdge {
  cursor: String!
  node: Runtime!
}

input RuntimeFilterInput {
  """Only return runtimes shared with this branch"""
  branchId: String
  runtimeVersions: [String!]
}

type RuntimeQuery {
  """Query a Runtime by ID"""
  byId(
    """Runtime ID to use to look up runtime"""
    runtimeId: ID!
  ): Runtime!
}

"""Represents the connection over the runtime edge of an App"""
type RuntimesConnection {
  edges: [RuntimeEdge!]!
  pageInfo: PageInfo!
}

"""Represents a human SSO (not robot) actor."""
type SSOUser implements Actor & UserActor {
  """Access Tokens belonging to this actor, none at present"""
  accessTokens: [AccessToken!]!
  accounts: [Account!]!

  """
  Coalesced project activity for all apps belonging to all accounts this user belongs to. Only resolves for the viewer.
  """
  activityTimelineProjectActivities(
    """ Offset the query """
    createdBefore: DateTime

    """ Types of objects to filter """
    filterTypes: [ActivityTimelineProjectActivityType!]
    limit: Int!
  ): [ActivityTimelineProjectActivity!]!
  appCount: Int!
  appetizeCode: String @deprecated

  """
  Apps this user has published. If this user is the viewer, this field returns the apps the user has access to.
  """
  apps(includeUnpublished: Boolean, limit: Int!, offset: Int!): [App!]!
  bestContactEmail: String
  created: DateTime!

  """Discord account linked to a user"""
  discordUser: DiscordUser
  displayName: String!

  """Experiments associated with this actor"""
  experiments: [ActorExperiment!]!

  """
  Server feature gate values for this actor, optionally filtering by desired gates.
  Only resolves for the viewer.
  """
  featureGates(filter: [String!]): JSONObject!
  firstName: String
  fullName: String

  """GitHub account linked to a user"""
  githubUser: GitHubUser
  githubUsername: String @deprecated
  id: ID!
  industry: String @deprecated
  isExpoAdmin: Boolean!
  lastDeletionAttemptTime: DateTime
  lastName: String
  location: String @deprecated
  notificationSubscriptions(filter: NotificationSubscriptionFilter): [NotificationSubscription!]!
  pinnedApps: [App!]!
  preferences: UserPreferences!

  """Associated accounts"""
  primaryAccount: Account!
  primaryAccountProfileImageUrl: String
  profilePhoto: String!

  """Snacks associated with this account"""
  snacks(limit: Int!, offset: Int!): [Snack!]!
  twitterUsername: String @deprecated
  username: String!
  websiteNotificationsPaginated(after: String, before: String, first: Int, last: Int): WebsiteNotificationsConnection!
}

input SSOUserDataInput {
  firstName: String
  lastName: String
}

type SecondFactorBooleanResult {
  success: Boolean!
}

input SecondFactorDeviceConfiguration {
  isPrimary: Boolean!
  method: SecondFactorMethod!
  name: String!
  smsPhoneNumber: String
}

type SecondFactorDeviceConfigurationResult {
  keyURI: String!
  secondFactorDevice: UserSecondFactorDevice!
  secret: String!
}

type SecondFactorInitiationResult {
  configurationResults: [SecondFactorDeviceConfigurationResult!]!
  plaintextBackupCodes: [String!]!
}

enum SecondFactorMethod {
  """Google Authenticator (TOTP)"""
  AUTHENTICATOR

  """SMS"""
  SMS
}

type SecondFactorRegenerateBackupCodesResult {
  plaintextBackupCodes: [String!]!
}

type SentryInstallation {
  account: Account!
  createdAt: DateTime!
  id: ID!
  installationId: String!
  orgSlug: String!
}

type SentryInstallationMutation {
  """Confirm a pending Sentry installation"""
  confirmPendingSentryInstallation(installationId: ID!): SentryInstallation!

  """Generate a Sentry token for an installation"""
  generateSentryToken(accountId: ID!): GenerateSentryTokenResult!

  """Link a Sentry installation to an Expo account"""
  linkSentryInstallationToExpoAccount(input: LinkSentryInstallationToExpoAccountInput!): PendingSentryInstallation!
}

type SentryProject {
  app: App!
  createdAt: DateTime!
  id: ID!
  sentryInstallationId: ID!
  sentryProjectId: String!
  sentryProjectSlug: String!
  updatedAt: DateTime!
}

type SentryProjectMutation {
  """Create a Sentry project"""
  createSentryProject(input: CreateSentryProjectInput!): SentryProject!

  """Delete a Sentry project by ID"""
  deleteSentryProject(sentryProjectId: ID!): DeleteSentryProjectResult!
}

type Snack implements Project {
  """Description of the Snack"""
  description: String!

  """
  Full name of the Snack, e.g. "@john/mysnack", "@snack/245631"
  """
  fullName: String!

  """Has the Snack been run without errors"""
  hasBeenRunSuccessfully: Boolean
  hashId: String!
  iconUrl: String @deprecated
  id: ID!

  """
  Draft status, which is true when the Snack was not saved explicitly, but auto-saved
  """
  isDraft: Boolean!

  """
  Name of the Snack, e.g. "My Snack"
  """
  name: String!

  """Preview image of the running snack"""
  previewImage: String
  published: Boolean!

  """SDK version of the snack"""
  sdkVersion: String!

  """
  Slug name, e.g. "mysnack", "245631"
  """
  slug: String!

  """Date and time the Snack was last updated"""
  updated: DateTime!

  """
  Name of the user that created the Snack, or "snack" when the Snack was saved anonymously
  """
  username: String!
}

type SnackQuery {
  """Get snack by hashId"""
  byHashId(hashId: ID!): Snack!

  """Get snack by hashId"""
  byId(id: ID!): Snack! @deprecated(reason: "Use byHashId")
}

enum StandardOffer {
  """$29 USD per month, 30 day trial"""
  DEFAULT

  """$800 USD per month"""
  SUPPORT

  """$29 USD per month, 1 year trial"""
  YC_DEALS

  """$348 USD per year, 30 day trial"""
  YEARLY_SUB
}

"""Incident for a given component from Expo status page API."""
type StatuspageIncident {
  createdAt: DateTime!
  id: ID!

  """Impact of an incident from Expo status page."""
  impact: StatuspageIncidentImpact!
  name: String!
  resolvedAt: DateTime

  """Shortlink to the incident from Expo status page."""
  shortlink: String!

  """Current status of an incident from Expo status page."""
  status: StatuspageIncidentStatus!
  updatedAt: DateTime!

  """List of all updates for an incident from Expo status page."""
  updates: [StatuspageIncidentUpdate!]!
}

"""Possible Incident impact values from Expo status page API."""
enum StatuspageIncidentImpact {
  CRITICAL
  MAINTENANCE
  MAJOR
  MINOR
  NONE
}

"""Possible Incident statuses from Expo status page API."""
enum StatuspageIncidentStatus {
  COMPLETED
  IDENTIFIED
  INVESTIGATING
  IN_PROGRESS
  MONITORING
  RESOLVED
  SCHEDULED
  VERIFYING
}

"""Update for an Incident from Expo status page API."""
type StatuspageIncidentUpdate {
  """Text of an update from Expo status page."""
  body: String!
  createdAt: DateTime!
  id: ID!

  """Status set at the moment of update."""
  status: StatuspageIncidentStatus!
}

"""Service monitored by Expo status page."""
type StatuspageService {
  """Description of a service from Expo status page."""
  description: String
  id: ID!

  """
  List of last inicdents for a service from Expo status page (we always query for 50 latest incidents for all services)
  sorted by createdAt field in descending order.
  """
  incidents: [StatuspageIncident!]!

  """Name of a service monitored by Expo status page."""
  name: StatuspageServiceName!

  """Current status of a service from Expo status page."""
  status: StatuspageServiceStatus!
}

"""Name of a service monitored by Expo status page."""
enum StatuspageServiceName {
  EAS_BUILD
  EAS_SUBMIT
  EAS_UPDATE
  GITHUB_API_REQUESTS
  GITHUB_WEBHOOKS
}

type StatuspageServiceQuery {
  """Query services from Expo status page by names."""
  byServiceNames(
    """Service names to use to look up components."""
    serviceNames: [StatuspageServiceName!]!
  ): [StatuspageService!]!
}

"""Possible statuses for a service."""
enum StatuspageServiceStatus {
  DEGRADED_PERFORMANCE
  MAJOR_OUTAGE
  OPERATIONAL
  PARTIAL_OUTAGE
  UNDER_MAINTENANCE
}

type StripeCoupon {
  amountOff: String
  appliesTo: String
  id: ID!
  name: String!
  percentOff: Float
  valid: Boolean!
}

type StripePrice {
  id: ID!
}

"""Represents an EAS Submission"""
type Submission implements ActivityTimelineProjectActivity {
  activityTimestamp: DateTime!
  actor: Actor
  androidConfig: AndroidSubmissionConfig
  app: App!
  archiveUrl: String
  canRetry: Boolean!
  cancelingActor: Actor
  childSubmission: Submission
  completedAt: DateTime
  createdAt: DateTime!
  error: SubmissionError
  id: ID!
  initiatingActor: Actor
  iosConfig: IosSubmissionConfig
  logFiles: [String!]!
  logsUrl: String @deprecated(reason: "Use logFiles instead")

  """Retry time starts after completedAt"""
  maxRetryTimeMinutes: Int!
  parentSubmission: Submission
  platform: AppPlatform!
  priority: SubmissionPriority
  status: SubmissionStatus!
  submittedBuild: Build
  updatedAt: DateTime!
}

enum SubmissionAndroidArchiveType {
  AAB
  APK
}

enum SubmissionAndroidReleaseStatus {
  COMPLETED
  DRAFT
  HALTED
  IN_PROGRESS
}

enum SubmissionAndroidTrack {
  ALPHA
  BETA
  INTERNAL
  PRODUCTION
}

input SubmissionArchiveSourceInput {
  """
  Required if the archive source type is GCS_BUILD_APPLICATION_ARCHIVE, GCS_BUILD_APPLICATION_ARCHIVE_ORCHESTRATOR or GCS_SUBMIT_ARCHIVE
  """
  bucketKey: String
  type: SubmissionArchiveSourceType!

  """Required if the archive source type is URL"""
  url: String
}

enum SubmissionArchiveSourceType {
  GCS_BUILD_APPLICATION_ARCHIVE
  GCS_BUILD_APPLICATION_ARCHIVE_ORCHESTRATOR
  GCS_SUBMIT_ARCHIVE
  URL
}

type SubmissionError {
  errorCode: String
  message: String
}

input SubmissionFilter {
  platform: AppPlatform
  status: SubmissionStatus
}

type SubmissionMutation {
  """Cancel an EAS Submit submission"""
  cancelSubmission(submissionId: ID!): Submission!

  """Create an Android EAS Submit submission"""
  createAndroidSubmission(input: CreateAndroidSubmissionInput!): CreateSubmissionResult!

  """Create an iOS EAS Submit submission"""
  createIosSubmission(input: CreateIosSubmissionInput!): CreateSubmissionResult!

  """Retry an EAS Submit submission"""
  retrySubmission(parentSubmissionId: ID!): CreateSubmissionResult!
}

enum SubmissionPriority {
  HIGH
  NORMAL
}

type SubmissionQuery {
  """Look up EAS Submission by submission ID"""
  byId(submissionId: ID!): Submission!
}

enum SubmissionStatus {
  AWAITING_BUILD
  CANCELED
  ERRORED
  FINISHED
  IN_PROGRESS
  IN_QUEUE
}

type SubscribeToNotificationResult {
  notificationSubscription: NotificationSubscription!
}

type SubscriptionDetails {
  addons: [AddonDetails!]!
  cancelAt: DateTime
  concurrencies: Concurrencies
  coupon: StripeCoupon
  endedAt: DateTime
  futureSubscription: FutureSubscription
  id: ID!
  isDowngrading: Boolean
  meteredBillingStatus: MeteredBillingStatus!
  name: String
  nextInvoice: DateTime
  nextInvoiceAmountDueCents: Int
  planEnablement(serviceMetric: EASServiceMetric!): PlanEnablement
  planId: String
  price: Int!
  recurringCents: Int
  status: String
  trialEnd: DateTime
  upcomingInvoice: Invoice
  willCancel: Boolean
}

enum TargetEntityMutationType {
  CREATE
  DELETE
  UPDATE
}

type TestNotificationMetadata {
  message: String!
}

type TimelineActivityConnection {
  edges: [TimelineActivityEdge!]!
  pageInfo: PageInfo!
}

type TimelineActivityEdge {
  cursor: String!
  node: ActivityTimelineProjectActivity!
}

input TimelineActivityFilterInput {
  channels: [String!]
  platforms: [AppPlatform!]
  releaseChannels: [String!]
  types: [ActivityTimelineProjectActivityType!]
}

type UniqueUsersOverTimeData {
  data: LineChartData!
}

type UnsubscribeFromNotificationResult {
  notificationSubscription: NotificationSubscription!
}

type Update implements ActivityTimelineProjectActivity {
  activityTimestamp: DateTime!
  actor: Actor
  app: App!
  assetMapUrl: String
  awaitingCodeSigningInfo: Boolean!
  branch: UpdateBranch!
  branchId: ID!
  codeSigningInfo: CodeSigningInfo
  createdAt: DateTime!
  deployments(after: String, before: String, first: Int, last: Int): DeploymentResult!
  environment: EnvironmentVariableEnvironment
  expoGoSDKVersion: String
  fingerprint: Fingerprint
  gitCommitHash: String
  group: String!
  id: ID!

  """Update query field"""
  insights: UpdateInsights!
  isGitWorkingTreeDirty: Boolean!
  isRollBackToEmbedded: Boolean!
  jobRun: JobRun
  manifestFragment: String!
  manifestPermalink: String!
  message: String
  platform: String!
  rolloutControlUpdate: Update
  rolloutPercentage: Int
  runtime: Runtime!
  runtimeVersion: String! @deprecated(reason: "Use 'runtime' field .")
  updatedAt: DateTime!
}

type UpdateBranch {
  app: App!
  appId: ID!
  createdAt: DateTime!
  id: ID!
  latestActivity: DateTime!
  name: String!
  runtimes(after: String, before: String, filter: RuntimeFilterInput, first: Int, last: Int): RuntimesConnection!
  updateGroups(filter: UpdatesFilter, limit: Int!, offset: Int!): [[Update!]!]!
  updatedAt: DateTime!
  updates(filter: UpdatesFilter, limit: Int!, offset: Int!): [Update!]!
}

type UpdateBranchMutation {
  """Create an EAS branch for an app"""
  createUpdateBranchForApp(appId: ID!, name: String!): UpdateBranch!

  """
  Delete an EAS branch and all of its updates as long as the branch is not being used by any channels
  """
  deleteUpdateBranch(branchId: ID!): DeleteUpdateBranchResult!

  """
  Edit an EAS branch. The branch can be specified either by its ID or
  with the combination of (appId, name).
  """
  editUpdateBranch(input: EditUpdateBranchInput!): UpdateBranch!

  """Publish an update group to a branch"""
  publishUpdateGroups(publishUpdateGroupsInput: [PublishUpdateGroupInput!]!): [Update!]!
}

type UpdateChannel {
  app: App!
  appId: ID!
  branchMapping: String!
  createdAt: DateTime!
  id: ID!
  isPaused: Boolean!
  name: String!
  updateBranches(limit: Int!, offset: Int!): [UpdateBranch!]!
  updatedAt: DateTime!
}

type UpdateChannelMutation {
  """
  Create an EAS channel for an app.
  
  In order to work with GraphQL formatting, the branchMapping should be a
  stringified JSON supplied to the mutation as a variable.
  """
  createUpdateChannelForApp(appId: ID!, branchMapping: String, name: String!): UpdateChannel!

  """delete an EAS channel that doesn't point to any branches"""
  deleteUpdateChannel(channelId: ID!): DeleteUpdateChannelResult!

  """
  Edit an EAS channel.
  
  In order to work with GraphQL formatting, the branchMapping should be a
  stringified JSON supplied to the mutation as a variable.
  """
  editUpdateChannel(branchMapping: String!, channelId: ID!): UpdateChannel!

  """Pause updates for an EAS channel."""
  pauseUpdateChannel(channelId: ID!): UpdateChannel!

  """Resume updates for an EAS channel."""
  resumeUpdateChannel(channelId: ID!): UpdateChannel!
}

type UpdateDeploymentEdge {
  cursor: String!
  node: Deployment!
}

type UpdateDeploymentsConnection {
  edges: [UpdateDeploymentEdge!]!
  pageInfo: PageInfo!
}

input UpdateEnvironmentVariableInput {
  environments: [EnvironmentVariableEnvironment!]
  fileName: String
  id: ID!
  isGlobal: Boolean
  name: String
  type: EnvironmentSecretType
  value: String
  visibility: EnvironmentVariableVisibility
}

input UpdateFilterInput {
  fingerprintHash: String
  hasFingerprint: Boolean
  runtimeVersion: String
}

input UpdateGitHubBuildTriggerInput {
  autoSubmit: Boolean!
  buildProfile: String!
  environment: EnvironmentVariableEnvironment
  executionBehavior: GitHubBuildTriggerExecutionBehavior!
  isActive: Boolean!
  platform: AppPlatform!
  sourcePattern: String!
  submitProfile: String
  targetPattern: String
  type: GitHubBuildTriggerType!
}

input UpdateGitHubJobRunTriggerInput {
  isActive: Boolean!
  sourcePattern: String!
  targetPattern: String
}

input UpdateGitHubRepositorySettingsInput {
  baseDirectory: String!
}

input UpdateInfoGroup {
  android: PartialManifest
  ios: PartialManifest
  web: PartialManifest
}

type UpdateInsights {
  averageAssetMetrics: [AverageAssetMetrics!]!
  cumulativeAverageMetrics: CumulativeAverageMetrics!
  cumulativeMetrics(timespan: InsightsTimespan!): CumulativeMetrics!
  id: ID!
  totalUniqueUsers(timespan: InsightsTimespan!): Int!
}

type UpdateMutation {
  """Delete an EAS update group"""
  deleteUpdateGroup(group: ID!): DeleteUpdateGroupResult! @deprecated(reason: "Use scheduleUpdateGroupDeletion instead")

  """Delete an EAS update group in the background"""
  scheduleUpdateGroupDeletion(group: ID!): BackgroundJobReceipt!

  """Set code signing info for an update"""
  setCodeSigningInfo(codeSigningInfo: CodeSigningInfoInput!, updateId: ID!): Update!

  """Set rollout percentage for an update"""
  setRolloutPercentage(percentage: Int!, updateId: ID!): Update!
}

type UpdateQuery {
  """Query an Update by ID"""
  byId(
    """Update ID to use to look up update"""
    updateId: ID!
  ): Update!
}

input UpdateRollBackToEmbeddedGroup {
  android: Boolean
  ios: Boolean
  web: Boolean
}

input UpdateRolloutInfo {
  rolloutControlUpdateId: ID!
  rolloutPercentage: Int!
}

input UpdateRolloutInfoGroup {
  android: UpdateRolloutInfo
  ios: UpdateRolloutInfo
  web: UpdateRolloutInfo
}

input UpdatesFilter {
  platform: AppPlatform
  runtimeVersions: [String!]
  sdkVersions: [String!]
}

type UpdatesMetricsData {
  failedInstallsDataset: CumulativeUpdatesDataset!
  installsDataset: CumulativeUpdatesDataset!
  labels: [String!]!
}

type UploadSession {
  """Create an Upload Session for a specific account"""
  createAccountScopedUploadSession(accountID: ID!, type: AccountUploadSessionType!): JSONObject!

  """Create an Upload Session for a specific app"""
  createAppScopedUploadSession(appID: ID!, type: AppUploadSessionType!): JSONObject!

  """Create an Upload Session"""
  createUploadSession(filename: String, type: UploadSessionType!): JSONObject!
}

enum UploadSessionType {
  EAS_BUILD_GCS_PROJECT_METADATA
  EAS_BUILD_GCS_PROJECT_SOURCES
  EAS_BUILD_PROJECT_SOURCES @deprecated(reason: "Use EAS_BUILD_GCS_PROJECT_SOURCES instead.")
  EAS_SHARE_GCS_APP_ARCHIVE
  EAS_SUBMIT_APP_ARCHIVE @deprecated(reason: "Use EAS_SUBMIT_GCS_APP_ARCHIVE instead.")
  EAS_SUBMIT_GCS_APP_ARCHIVE
  EAS_UPDATE_ASSETS_METADATA
  EAS_UPDATE_FINGERPRINT
}

type UsageMetricTotal {
  billingPeriod: BillingPeriod!
  id: ID!
  overageMetrics: [EstimatedOverageAndCost!]!
  planMetrics: [EstimatedUsage!]!

  """Total cost of overages, in cents"""
  totalCost: Float!
}

enum UsageMetricType {
  BANDWIDTH
  BUILD
  MINUTE
  REQUEST
  UPDATE
  USER
}

enum UsageMetricsGranularity {
  DAY
  HOUR
  MINUTE
  TOTAL
}

input UsageMetricsTimespan {
  end: DateTime!
  start: DateTime!
}

"""Represents a human (not robot) actor."""
type User implements Actor & UserActor {
  """Access Tokens belonging to this actor"""
  accessTokens: [AccessToken!]!
  accounts: [Account!]!

  """
  Coalesced project activity for all apps belonging to all accounts this user belongs to. Only resolves for the viewer.
  """
  activityTimelineProjectActivities(
    """ Offset the query """
    createdBefore: DateTime

    """ Types of objects to filter """
    filterTypes: [ActivityTimelineProjectActivityType!]
    limit: Int!
  ): [ActivityTimelineProjectActivity!]!
  appCount: Int!
  appetizeCode: String @deprecated

  """Apps this user has published"""
  apps(includeUnpublished: Boolean, limit: Int!, offset: Int!): [App!]!
  bestContactEmail: String
  created: DateTime!

  """Discord account linked to a user"""
  discordUser: DiscordUser
  displayName: String!
  email: String!
  emailVerified: Boolean!

  """Experiments associated with this actor"""
  experiments: [ActorExperiment!]!

  """
  Server feature gate values for this actor, optionally filtering by desired gates.
  Only resolves for the viewer.
  """
  featureGates(filter: [String!]): JSONObject!
  firstName: String
  fullName: String

  """GitHub account linked to a user"""
  githubUser: GitHubUser
  githubUsername: String @deprecated

  """
  Whether this user has any pending user invitations. Only resolves for the viewer.
  """
  hasPendingUserInvitations: Boolean!
  id: ID!
  industry: String @deprecated
  isExpoAdmin: Boolean!
  isLegacy: Boolean! @deprecated
  isSecondFactorAuthenticationEnabled: Boolean!
  lastDeletionAttemptTime: DateTime
  lastName: String
  location: String @deprecated
  notificationSubscriptions(filter: NotificationSubscriptionFilter): [NotificationSubscription!]!

  """Pending UserInvitations for this user. Only resolves for the viewer."""
  pendingUserInvitations: [UserInvitation!]!
  pinnedApps: [App!]!
  preferences: UserPreferences!

  """Associated accounts"""
  primaryAccount: Account!
  primaryAccountProfileImageUrl: String
  profilePhoto: String!

  """Get all certified second factor authentication methods"""
  secondFactorDevices: [UserSecondFactorDevice!]!

  """Snacks associated with this account"""
  snacks(limit: Int!, offset: Int!): [Snack!]!
  twitterUsername: String @deprecated
  username: String!
  websiteNotificationsPaginated(after: String, before: String, first: Int, last: Int): WebsiteNotificationsConnection!
}

"""
A human user (type User or SSOUser) that can login to the Expo website, use Expo services, and be a member of accounts.
"""
interface UserActor implements Actor {
  """Access Tokens belonging to this user actor"""
  accessTokens: [AccessToken!]!
  accounts: [Account!]!

  """
  Coalesced project activity for all apps belonging to all accounts this user actor belongs to.
  Only resolves for the viewer.
  """
  activityTimelineProjectActivities(
    """ Offset the query """
    createdBefore: DateTime

    """ Types of objects to filter """
    filterTypes: [ActivityTimelineProjectActivityType!]
    limit: Int!
  ): [ActivityTimelineProjectActivity!]!
  appCount: Int!
  appetizeCode: String @deprecated

  """Apps this user has published"""
  apps(includeUnpublished: Boolean, limit: Int!, offset: Int!): [App!]!
  bestContactEmail: String
  created: DateTime!

  """Discord account linked to a user"""
  discordUser: DiscordUser

  """
  Best-effort human readable name for this human actor for use in user interfaces during action attribution.
  For example, when displaying a sentence indicating that actor X created a build or published an update.
  """
  displayName: String!

  """Experiments associated with this actor"""
  experiments: [ActorExperiment!]!

  """
  Server feature gate values for this user actor, optionally filtering by desired gates.
  Only resolves for the viewer.
  """
  featureGates(filter: [String!]): JSONObject!
  firstName: String
  fullName: String

  """GitHub account linked to a user"""
  githubUser: GitHubUser
  githubUsername: String @deprecated
  id: ID!
  industry: String @deprecated
  isExpoAdmin: Boolean!
  lastDeletionAttemptTime: DateTime
  lastName: String
  location: String @deprecated
  notificationSubscriptions(filter: NotificationSubscriptionFilter): [NotificationSubscription!]!
  pinnedApps: [App!]!
  preferences: UserPreferences!

  """Associated accounts"""
  primaryAccount: Account!
  primaryAccountProfileImageUrl: String
  profilePhoto: String!

  """Snacks associated with this user's personal account"""
  snacks(limit: Int!, offset: Int!): [Snack!]!
  twitterUsername: String @deprecated
  username: String!
  websiteNotificationsPaginated(after: String, before: String, first: Int, last: Int): WebsiteNotificationsConnection!
}

"""
A human user (type User or SSOUser) that can login to the Expo website, use Expo services, and be a member of accounts.
"""
type UserActorPublicData {
  firstName: String
  id: ID!
  lastName: String
  profilePhoto: String!

  """Snacks associated with this user's personal account"""
  snacks(limit: Int!, offset: Int!): [Snack!]!
  username: String!
}

type UserActorPublicDataQuery {
  """Get UserActorPublicData by username"""
  byUsername(username: String!): UserActorPublicData!
}

type UserActorQuery {
  """Query a UserActor by ID"""
  byId(id: ID!): UserActor! @deprecated(reason: "Public user actor queries are no longer supported")

  """Query a UserActor by username"""
  byUsername(username: String!): UserActor! @deprecated(reason: "Public user actor queries are no longer supported")
}

enum UserAgentBrowser {
  ANDROID_MOBILE
  CHROME
  CHROME_IOS
  EDGE
  FACEBOOK_MOBILE
  FIREFOX
  FIREFOX_IOS
  INTERNET_EXPLORER
  KONQUEROR
  MOZILLA
  OPERA
  SAFARI
  SAFARI_MOBILE
  SAMSUNG_INTERNET
  UC_BROWSER
}

enum UserAgentOS {
  ANDROID
  CHROME_OS
  IOS
  IPAD_OS
  LINUX
  MAC_OS
  WINDOWS
}

enum UserAgentPlatform {
  ANDROID
  APPLE
  UNKNOWN
  WEB
}

type UserAppPinMutation {
  pinApp(appId: ID!): ID!
  unpinApp(appId: ID!): ID
}

type UserAuditLog {
  actor: Actor!
  createdAt: DateTime!
  id: ID!
  ip: String
  metadata: JSONObject
  targetEntityId: ID!
  targetEntityMutationType: TargetEntityMutationType!
  targetEntityTypeName: UserEntityTypeName!
  targetEntityTypePublicName: String!
  user: User! @deprecated(reason: "Use userActor instead")
  userActor: UserActor!
  websiteMessage: String!
}

type UserAuditLogConnection {
  edges: [UserAuditLogEdge!]!
  pageInfo: PageInfo!
}

type UserAuditLogEdge {
  cursor: String!
  node: UserAuditLog!
}

input UserAuditLogExportInput {
  createdAfter: String!
  createdBefore: String!
  format: AuditLogsExportFormat!
  targetEntityMutationType: [TargetEntityMutationType!]
  targetEntityTypeName: [UserEntityTypeName!]
  userId: ID!
}

input UserAuditLogFilterInput {
  entityTypes: [UserEntityTypeName!]
  mutationTypes: [TargetEntityMutationType!]
}

type UserAuditLogMutation {
  """
  Exports User Audit Logs for an user. Returns the ID of the background job receipt. Use BackgroundJobReceiptQuery to get the status of the job.
  """
  exportUserAuditLogs(exportInput: UserAuditLogExportInput!): BackgroundJobReceipt!
}

type UserAuditLogQuery {
  """Audit logs for user"""
  byId(auditLogId: ID!): UserAuditLog!
  byUserIdPaginated(after: String, before: String, filter: UserAuditLogFilterInput, first: Int, last: Int, userId: ID!): UserAuditLogConnection!
  typeNamesMap: [UserLogNameTypeMapping!]!
}

input UserDataInput {
  email: String
  firstName: String
  fullName: String
  id: ID
  lastName: String
  profilePhoto: String
  username: String
}

enum UserEntityTypeName {
  AccessTokenEntity
  DiscordUserEntity
  GitHubUserEntity
  PasswordEntity
  SSOUserEntity
  UserEntity
  UserPermissionEntity
  UserSecondFactorBackupCodesEntity
  UserSecondFactorDeviceEntity
}

"""
An pending invitation sent to an email granting membership on an Account.
"""
type UserInvitation {
  accountName: String!

  """The profile image URL of the account owner"""
  accountProfileImageUrl: String!

  """
  If the invite is for a personal team, the profile photo of account owner
  """
  accountProfilePhoto: String @deprecated(reason: "Use accountProfileImageUrl")
  created: DateTime!

  """Email to which this invitation was sent"""
  email: String!
  expires: DateTime!
  id: ID!

  """If the invite is for an organization or a personal team"""
  isForOrganization: Boolean!

  """Account permissions to be granted upon acceptance of this invitation"""
  permissions: [Permission!]!

  """Role to be granted upon acceptance of this invitation"""
  role: Role!
}

type UserInvitationMutation {
  """
  Accept UserInvitation by ID. Viewer must have matching email and email must be verified.
  """
  acceptUserInvitationAsViewer(id: ID!): AcceptUserInvitationResult!

  """
  Accept UserInvitation by token. Note that the viewer's email is not required to match
  the email on the invitation. If viewer's email does match that of the invitation,
  their email will also be verified.
  """
  acceptUserInvitationByTokenAsViewer(token: ID!): AcceptUserInvitationResult!

  """
  Create a UserInvitation for an email that when accepted grants
  the specified permissions on an Account
  """
  createUserInvitationForAccount(accountID: ID!, email: String!, permissions: [Permission]!): UserInvitation!

  """Rescind UserInvitation by ID"""
  deleteUserInvitation(id: ID!): RescindUserInvitationResult!

  """
  Delete UserInvitation by token. Note that the viewer's email is not required to match
  the email on the invitation.
  """
  deleteUserInvitationByToken(token: ID!): RescindUserInvitationResult!

  """Re-send UserInivitation by ID"""
  resendUserInvitation(id: ID!): UserInvitation!
}

"""Publicly visible data for a UserInvitation."""
type UserInvitationPublicData {
  accountName: String!
  accountProfileImageUrl: String!
  accountProfilePhoto: String
  created: DateTime!
  email: String!
  expires: DateTime!

  """Email to which this invitation was sent"""
  id: ID!
  isForOrganization: Boolean!
}

type UserInvitationPublicDataQuery {
  """Get UserInvitationPublicData by token"""
  byToken(token: ID!): UserInvitationPublicData!
}

type UserLogNameTypeMapping {
  publicName: String!
  typeName: UserEntityTypeName!
}

type UserPermission {
  actor: Actor!
  permissions: [Permission!]!
  role: Role!
  user: User @deprecated(reason: "User type is deprecated")
  userActor: UserActor
}

type UserPreferences {
  onboarding: UserPreferencesOnboarding
  selectedAccountName: String
}

input UserPreferencesInput {
  onboarding: UserPreferencesOnboardingInput
  selectedAccountName: String
}

"""
Set by website. Used by CLI to continue onboarding process on user's machine - clone repository,
install dependencies etc.
"""
type UserPreferencesOnboarding {
  appId: ID!

  """Can be null if the user has not selected one yet."""
  deviceType: OnboardingDeviceType

  """Can be null if the user has not selected one yet."""
  environment: OnboardingEnvironment

  """
  Set by CLI when the user has completed that phase. Used by the website to determine when
  the next step can be shown.
  """
  isCLIDone: Boolean

  """The last time when this object was updated."""
  lastUsed: String!

  """
  User selects a platform for which they want to build the app. CLI uses this information to start the build.
  """
  platform: AppPlatform
}

input UserPreferencesOnboardingInput {
  appId: ID!
  deviceType: OnboardingDeviceType
  environment: OnboardingEnvironment
  isCLIDone: Boolean
  lastUsed: String!
  platform: AppPlatform
}

type UserQuery {
  """Query a User by ID"""
  byId(userId: ID!): User! @deprecated(reason: "Public user queries are no longer supported")

  """Query a User by username"""
  byUsername(username: String!): User! @deprecated(reason: "Public user queries are no longer supported")
}

"""A second factor device belonging to a User"""
type UserSecondFactorDevice {
  createdAt: DateTime!
  id: ID!
  isCertified: Boolean!
  isPrimary: Boolean!
  method: SecondFactorMethod!
  name: String!
  smsPhoneNumber: String
  updatedAt: DateTime!
  user: User!
}

input WebNotificationUpdateReadStateInput {
  id: ID!
  isRead: Boolean!
}

type Webhook {
  appId: ID!
  createdAt: DateTime!
  event: WebhookType!
  id: ID!
  updatedAt: DateTime!
  url: String!
}

input WebhookFilter {
  event: WebhookType
}

input WebhookInput {
  event: WebhookType!
  secret: String!
  url: String!
}

type WebhookMutation {
  """Create a Webhook"""
  createWebhook(appId: String!, webhookInput: WebhookInput!): Webhook!

  """Delete a Webhook"""
  deleteWebhook(webhookId: ID!): DeleteWebhookResult!

  """Update a Webhook"""
  updateWebhook(webhookId: ID!, webhookInput: WebhookInput!): Webhook!
}

type WebhookQuery {
  byId(id: ID!): Webhook!
}

enum WebhookType {
  BUILD
  SUBMIT
}

type WebsiteNotificationEdge {
  cursor: String!
  node: Notification!
}

type WebsiteNotificationMutation {
  updateAllWebsiteNotificationReadStateAsRead: Boolean!
  updateNotificationReadState(input: WebNotificationUpdateReadStateInput!): Notification!
}

type WebsiteNotificationsConnection {
  edges: [WebsiteNotificationEdge!]!
  pageInfo: PageInfo!
}

type WorkerCustomDomain {
  alias: WorkerDeploymentAlias!
  createdAt: DateTime!
  dcvDelegationRecord: CustomDomainDNSRecord
  devDomainName: DevDomainName!
  dnsRecord: CustomDomainDNSRecord!
  hostname: String!
  id: ID!
  setup: CustomDomainSetup
  updatedAt: DateTime!
  verificationRecord: CustomDomainDNSRecord
}

type WorkerDeployment implements ActivityTimelineProjectActivity {
  activityTimestamp: DateTime!
  actor: Actor
  aliases: [WorkerDeploymentAlias!]
  app: App!
  crashes(filters: CrashesFilters, timespan: DatasetTimespan!): WorkerDeploymentCrashes
  createdAt: DateTime!
  deploymentDomain: String!
  deploymentIdentifier: WorkerDeploymentIdentifier!
  devDomainName: DevDomainName!
  id: ID!
  initiatingActor: Actor
  logs(limit: Int = 500, timespan: LogsTimespan!): WorkerDeploymentLogs
  requests(filters: RequestsFilters, timespan: DatasetTimespan!): WorkerDeploymentRequests
  signedAssetsURL: String!
  signedDeploymentURL: String!
  subdomain: String!
  url: String!
}

type WorkerDeploymentAlias {
  aliasName: WorkerDeploymentIdentifier
  createdAt: DateTime!
  deploymentDomain: String!
  devDomainName: DevDomainName!
  id: ID!
  subdomain: String!
  updatedAt: DateTime!
  url: String!
  workerDeployment: WorkerDeployment!
}

type WorkerDeploymentAliasEdge {
  cursor: String!
  node: WorkerDeploymentAlias!
}

type WorkerDeploymentAliasesConnection {
  edges: [WorkerDeploymentAliasEdge!]!
  pageInfo: PageInfo!
}

type WorkerDeploymentCrashEdge {
  logs: [WorkerDeploymentLogNode!]!
  node: WorkerDeploymentCrashNode!
  request: WorkerDeploymentRequestNode
}

enum WorkerDeploymentCrashKind {
  EXCEEDED_CPU
  EXCEEDED_MEMORY
  EXCEEDED_SUBREQUESTS
  GENERIC
  INTERNAL
  RESPONSE_STREAM_DISCONNECTED
}

type WorkerDeploymentCrashNode {
  crashHash: ID!
  crashKind: WorkerDeploymentCrashKind!
  crashTimestamp: DateTime!
  deploymentIdentifier: String!
  firstStackLine: String
  key: ID!
  message: String!
  name: String!
  requestTimestamp: DateTime!
  scriptName: String!
  stack: [String!]
}

type WorkerDeploymentCrashes {
  byCrashHash: [WorkerDeploymentCrashesHashEdge!]!
  byName: [WorkerDeploymentCrashesNameEdge!]!
  interval: Int!
  minRowsWithoutLimit: Int!
  nodes: [WorkerDeploymentCrashNode!]!
  summary: WorkerDeploymentCrashesAggregationNode!
  timeseries: [WorkerDeploymentCrashesTimeseriesEdge!]!
}

type WorkerDeploymentCrashesAggregationNode {
  crashesPerMs: Float
  crashesSum: Int!
  distinctCrashes: Int!
  firstOccurredAt: DateTime!
  mostRecentlyOccurredAt: DateTime!
  sampleRate: Float
}

type WorkerDeploymentCrashesHashEdge {
  crashHash: ID!
  node: WorkerDeploymentCrashesAggregationNode!
  sample: WorkerDeploymentCrashNode!
  timeseries: [WorkerDeploymentCrashesTimeseriesEdge!]!
}

type WorkerDeploymentCrashesNameEdge {
  name: String!
  node: WorkerDeploymentCrashesAggregationNode!
  sample: WorkerDeploymentCrashNode!
  timeseries: [WorkerDeploymentCrashesTimeseriesEdge!]!
}

type WorkerDeploymentCrashesTimeseriesEdge {
  node: WorkerDeploymentCrashesAggregationNode
  timestamp: DateTime!
}

type WorkerDeploymentEdge {
  cursor: String!
  node: WorkerDeployment!
}

"""A alias name for a serverless deployment"""
scalar WorkerDeploymentIdentifier

enum WorkerDeploymentLogLevel {
  DEBUG
  ERROR
  FATAL
  INFO
  LOG
  WARN
}

type WorkerDeploymentLogNode {
  level: WorkerDeploymentLogLevel!
  message: String!
  timestamp: DateTime!
}

type WorkerDeploymentLogs {
  minRowsWithoutLimit: Int
  nodes: [WorkerDeploymentLogNode!]!
}

type WorkerDeploymentQuery {
  byId(id: ID!): WorkerDeployment!
}

type WorkerDeploymentRequestEdge {
  crash: WorkerDeploymentCrashNode
  logs: [WorkerDeploymentLogNode!]!
  node: WorkerDeploymentRequestNode!
}

"""A Worker Deployment Request ID (also known as the CF Ray ID)"""
scalar WorkerDeploymentRequestID

type WorkerDeploymentRequestNode {
  browserKind: UserAgentBrowser
  browserVersion: String
  cacheStatus: ResponseCacheStatus
  continent: ContinentCode
  country: String
  deploymentIdentifier: String!
  duration: Int!
  hasCustomDomainOrigin: Boolean!
  isAsset: Boolean!
  isCrash: Boolean!
  isLimitExceeded: Boolean!
  isRejected: Boolean!
  isStaleIfError: Boolean!
  isStaleWhileRevalidate: Boolean!
  isVerifiedBot: Boolean!
  key: ID!
  method: String!
  os: UserAgentOS
  pathname: String!
  platform: UserAgentPlatform!
  region: String
  requestId: WorkerDeploymentRequestID!
  requestTimestamp: DateTime!
  responseType: ResponseType!
  scriptName: String!
  search: String
  status: Int!
  statusType: ResponseStatusType
}

type WorkerDeploymentRequests {
  byBrowser(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsBrowserEdge!]!
  byCacheStatus(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsCacheStatusEdge!]!
  byContinent(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsContinentEdge!]!
  byCountry(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsCountryEdge!]!
  byMethod(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsMethodEdge!]!
  byOS(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsOperatingSystemEdge!]!
  byPathname(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsPathnameEdge!]!
  byPlatform(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsPlatformEdge!]!
  byResponseType(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsResponseTypeEdge!]!
  byStatusType(limit: Int, orderBy: RequestsOrderBy): [WorkerDeploymentRequestsStatusTypeEdge!]!
  interval: Int!
  minRowsWithoutLimit: Int!
  nodes: [WorkerDeploymentRequestNode!]!
  summary: WorkerDeploymentRequestsAggregationNode!
  timeseries: [WorkerDeploymentRequestsTimeseriesEdge!]!
}

type WorkerDeploymentRequestsAggregationNode {
  assetsPerMs: Float
  assetsSum: Int!
  cacheHitRatio: Float!
  cacheHitRatioP50: Float!
  cacheHitRatioP90: Float!
  cacheHitRatioP99: Float!
  cacheHitsPerMs: Float
  cacheHitsSum: Int!
  cachePassRatio: Float!
  cachePassRatioP50: Float!
  cachePassRatioP90: Float!
  cachePassRatioP99: Float!
  clientErrorRatio: Float!
  clientErrorRatioP50: Float!
  clientErrorRatioP90: Float!
  clientErrorRatioP99: Float!
  crashRatio: Float!
  crashRatioP50: Float!
  crashRatioP90: Float!
  crashRatioP99: Float!
  crashesPerMs: Float
  crashesSum: Int!
  duration: Float!
  durationP50: Float!
  durationP90: Float!
  durationP99: Float!
  limitExceededPerMs: Float
  limitExceededSum: Int!
  requestsPerMs: Float
  requestsSum: Int!
  sampleRate: Float
  serverErrorRatio: Float!
  serverErrorRatioP50: Float!
  serverErrorRatioP90: Float!
  serverErrorRatioP99: Float!
  staleIfErrorPerMs: Float
  staleIfErrorSum: Int!
  staleWhileRevalidatePerMs: Float
  staleWhileRevalidateSum: Int!
}

type WorkerDeploymentRequestsBrowserEdge {
  browser: UserAgentBrowser
  node: WorkerDeploymentRequestsAggregationNode!
}

type WorkerDeploymentRequestsCacheStatusEdge {
  cacheStatus: ResponseCacheStatus
  node: WorkerDeploymentRequestsAggregationNode!
}

type WorkerDeploymentRequestsContinentEdge {
  continent: ContinentCode
  node: WorkerDeploymentRequestsAggregationNode!
}

type WorkerDeploymentRequestsCountryEdge {
  country: String
  node: WorkerDeploymentRequestsAggregationNode!
}

type WorkerDeploymentRequestsMethodEdge {
  method: String!
  node: WorkerDeploymentRequestsAggregationNode!
}

type WorkerDeploymentRequestsOperatingSystemEdge {
  node: WorkerDeploymentRequestsAggregationNode!
  os: UserAgentOS
}

type WorkerDeploymentRequestsPathnameEdge {
  node: WorkerDeploymentRequestsAggregationNode!
  pathname: String!
}

type WorkerDeploymentRequestsPlatformEdge {
  node: WorkerDeploymentRequestsAggregationNode!
  platform: UserAgentPlatform!
}

type WorkerDeploymentRequestsResponseTypeEdge {
  node: WorkerDeploymentRequestsAggregationNode!
  responseType: ResponseType!
}

type WorkerDeploymentRequestsStatusTypeEdge {
  node: WorkerDeploymentRequestsAggregationNode!
  statusType: ResponseStatusType
}

type WorkerDeploymentRequestsTimeseriesEdge {
  byBrowser: [WorkerDeploymentRequestsBrowserEdge!]!
  byCacheStatus: [WorkerDeploymentRequestsCacheStatusEdge!]!
  byContinent: [WorkerDeploymentRequestsContinentEdge!]!
  byCountry: [WorkerDeploymentRequestsCountryEdge!]!
  byMethod: [WorkerDeploymentRequestsMethodEdge!]!
  byOS: [WorkerDeploymentRequestsOperatingSystemEdge!]!
  byPathname: [WorkerDeploymentRequestsPathnameEdge!]!
  byPlatform: [WorkerDeploymentRequestsPlatformEdge!]!
  byResponseType: [WorkerDeploymentRequestsResponseTypeEdge!]!
  byStatusType: [WorkerDeploymentRequestsStatusTypeEdge!]!
  node: WorkerDeploymentRequestsAggregationNode
  timestamp: DateTime!
}

type WorkerDeploymentsConnection {
  edges: [WorkerDeploymentEdge!]!
  pageInfo: PageInfo!
}

enum WorkerLoggerLevel {
  DEBUG
  ERROR
  FATAL
  INFO
  TRACE
  WARN
}

type Workflow {
  app: App!
  createdAt: DateTime!
  fileName: String!
  id: ID!
  name: String
  revisionsPaginated(after: String, before: String, first: Int, last: Int): WorkflowRevisionsConnection!
  runsPaginated(after: String, before: String, first: Int, last: Int): WorkflowRunsConnection!
  updatedAt: DateTime!
}

type WorkflowArtifact {
  contentType: String
  createdAt: DateTime!
  downloadUrl: String
  fileSizeBytes: Int
  filename: String!
  id: ID!
  jobRun: JobRun!
  name: String!
  updatedAt: DateTime!
}

type WorkflowJob {
  createdAt: DateTime!
  credentialsAppleDeviceRegistrationRequest: AppleDeviceRegistrationRequest
  errors: [WorkflowJobError!]!
  id: ID!
  key: String!
  name: String!
  outputs: JSONObject!
  requiredJobKeys: [String!]!
  status: WorkflowJobStatus!
  turtleBuild: Build
  turtleJobRun: JobRun
  turtleSubmission: Submission
  type: WorkflowJobType!
  updatedAt: DateTime!
  workflowRun: WorkflowRun!
}

type WorkflowJobError {
  message: String!
  title: String!
}

type WorkflowJobMutation {
  approveWorkflowJob(workflowJobId: ID!): ID!
}

type WorkflowJobQuery {
  byId(workflowJobId: ID!): WorkflowJob!
}

enum WorkflowJobStatus {
  ACTION_REQUIRED
  CANCELED
  FAILURE
  IN_PROGRESS
  NEW
  PENDING_CANCEL
  SKIPPED
  SUCCESS
}

enum WorkflowJobType {
  APPLE_DEVICE_REGISTRATION_REQUEST
  BUILD
  CUSTOM
  DEPLOY
  FINGERPRINT
  GET_BUILD
  MAESTRO_TEST
  REQUIRE_APPROVAL
  SLACK
  SUBMISSION
  UPDATE
}

input WorkflowProjectSourceInput {
  easJsonBucketKey: String!
  packageJsonBucketKey: String
  projectArchiveBucketKey: String!
  type: WorkflowProjectSourceType!
}

enum WorkflowProjectSourceType {
  GCS
}

"""Look up Workflow by ID"""
type WorkflowQuery {
  byId(workflowId: ID!): Workflow!
}

type WorkflowRevision {
  blobSha: String!
  commitSha: String
  createdAt: DateTime!
  id: ID!
  workflow: Workflow!
  yamlConfig: String!
}

type WorkflowRevisionEdge {
  cursor: String!
  node: WorkflowRevision!
}

input WorkflowRevisionInput {
  fileName: String!
  yamlConfig: String!
}

type WorkflowRevisionMutation {
  validateWorkflowYamlConfig(appId: ID!, yamlConfig: String!): Boolean!
}

type WorkflowRevisionQuery {
  byId(workflowRevisionId: ID!): WorkflowRevision!
}

type WorkflowRevisionsConnection {
  edges: [WorkflowRevisionEdge!]!
  pageInfo: PageInfo!
}

type WorkflowRun implements ActivityTimelineProjectActivity {
  activityTimestamp: DateTime!
  actor: Actor
  createdAt: DateTime!
  errors: [WorkflowRunError!]!
  gitCommitHash: String
  gitCommitMessage: String
  githubRepository: GitHubRepository
  id: ID!
  jobs: [WorkflowJob!]!
  name: String!
  pullRequestNumber: Int
  requestedGitRef: String
  retriedWorkflowRun: WorkflowRun
  retries: [WorkflowRun!]!
  sourceExpiresAt: DateTime
  status: WorkflowRunStatus!
  triggerEventType: WorkflowRunTriggerEventType!
  triggeringLabelName: String
  triggeringSchedule: String
  updatedAt: DateTime!
  workflow: Workflow!
  workflowRevision: WorkflowRevision
}

type WorkflowRunEdge {
  cursor: String!
  node: WorkflowRun!
}

type WorkflowRunError {
  message: String!
  title: String
}

input WorkflowRunFilterInput {
  requestedGitRef: String
}

input WorkflowRunGitBranchFilterInput {
  searchTerm: String
}

input WorkflowRunInput {
  projectSource: WorkflowProjectSourceInput!
}

type WorkflowRunMutation {
  cancelWorkflowRun(workflowRunId: ID!): WorkflowRun!
  createWorkflowRun(appId: ID!, workflowRevisionInput: WorkflowRevisionInput!, workflowRunInput: WorkflowRunInput!): WorkflowRun!
  retryWorkflowRun(fromFailedJobs: Boolean, workflowRunId: ID!): WorkflowRun!
}

type WorkflowRunQuery {
  byId(workflowRunId: ID!): WorkflowRun!
}

enum WorkflowRunStatus {
  ACTION_REQUIRED
  CANCELED
  FAILURE
  IN_PROGRESS
  NEW
  PENDING_CANCEL
  SUCCESS
}

enum WorkflowRunTriggerEventType {
  GITHUB_PULL_REQUEST_LABELED
  GITHUB_PULL_REQUEST_OPENED
  GITHUB_PULL_REQUEST_REOPENED
  GITHUB_PULL_REQUEST_SYNCHRONIZE
  GITHUB_PUSH
  MANUAL
  SCHEDULE
}

type WorkflowRunsConnection {
  edges: [WorkflowRunEdge!]!
  pageInfo: PageInfo!
}

type deleteAndroidAppBuildCredentialsResult {
  id: ID!
}

type deleteAndroidFcmResult {
  id: ID!
}

type deleteAppStoreConnectApiKeyResult {
  id: ID!
}

type deleteApplePushKeyResult {
  id: ID!
}